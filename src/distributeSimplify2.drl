

//$$strtCprt
//
// Simple Algebra 
// 
// Copyright (C) 2014 Thornton Green
// 
// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with this program; if not, 
// see <http://www.gnu.org/licenses>.
// Additional permission under GNU GPL version 3 section 7
//
//
//$$endCprt

package simplealgebra.symbolic




import simplealgebra.SymbolicConjugateLeft;
import simplealgebra.SymbolicConjugateRight;
import simplealgebra.SymbolicInvertLeftRevCoeff;
import simplealgebra.SymbolicInvertRightRevCoeff;
import simplealgebra.SymbolicMultRevCoeff;
import simplealgebra.SymbolicTranspose;
import simplealgebra.ComplexElemFactory;
import simplealgebra.SquareMatrixElemFactory;
import simplealgebra.ddx.PartialDerivativeOp;
import simplealgebra.ddx.FlowVectorTensor;
import simplealgebra.ddx.MaterialDerivativeFactory;
import simplealgebra.ddx.DirectionalDerivative;
import simplealgebra.ddx.CovariantDerivative;
import simplealgebra.ddx.CovariantDerivativeFactory;
import simplealgebra.et.SymbolicIndexReduction;
import simplealgebra.et.SymbolicRankTwoTrace;
import simplealgebra.et.SymbolicRegenContravar;
import simplealgebra.et.SymbolicRegenCovar;
import simplealgebra.et.SymbolicTensorResym;
import simplealgebra.et.OrdinaryDerivative;
import simplealgebra.et.EinsteinTensorElemFactory;
import simplealgebra.ga.SymbolicReverseLeft;
import simplealgebra.ga.SymbolicReverseRight;
import simplealgebra.ga.SymbolicDot;
import simplealgebra.ga.SymbolicDotHestenes;
import simplealgebra.ga.SymbolicLeftContraction;
import simplealgebra.ga.SymbolicRightContraction;
import simplealgebra.ga.SymbolicWedge;
import simplealgebra.ga.SymbolicCross;
import simplealgebra.ga.SymbolicScalar;
import simplealgebra.ga.GeometricAlgebraMultivectorElemFactory;






// This simplification has a parallel implementation in SymbolicZero.negate()
rule "Double Negate"
     when
          n0 : SymbolicNegate( )
          n1 : SymbolicNegate( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
     then
          // System.out.println( "Double Negate" );
          insert( new Reng( n1 , e0 ) );
end






rule "Double Absolute Value"
     when
          n0 : SymbolicAbsoluteValue( )
          n1 : SymbolicAbsoluteValue( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
     then
          // System.out.println( "Double Absolute Value" );
          insert( new Reng( n1 , n0 ) );
end






rule "Absolute Value Identity"
     when
          n0 : SymbolicIdentity( )
          n1 : SymbolicAbsoluteValue( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
     then
          // System.out.println( "Absolute Value Identity" );
          insert( new Reng( n1 , n0 ) );
end






rule "Absolute Value Zero"
     when
          n0 : SymbolicZero( )
          n1 : SymbolicAbsoluteValue( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
     then
          // System.out.println( "Absolute Value Zero" );
          insert( new Reng( n1 , n0 ) );
end







rule "Double Invert Left NonCommute"
     when
          n0 : SymbolicInvertLeft( )
          n1 : SymbolicInvertRight( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
     then
          // System.out.println( "Double Invert Left NonCommute" );
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Right NonCommute"
     when
          n0 : SymbolicInvertRight( )
          n1 : SymbolicInvertLeft( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
     then
          // System.out.println( "Double Invert Right NonCommute" );
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Left Commute"
     when
          n0 : SymbolicInvertLeft( )
          n1 : SymbolicInvertLeft( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
          eval( e0.getFac().isNestedMultCommutative() )
     then
          // System.out.println( "Double Invert Left Commute" );
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Right Commute"
     when
          n0 : SymbolicInvertRight( )
          n1 : SymbolicInvertRight( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
          eval( e0.getFac().isNestedMultCommutative() )
     then
          // System.out.println( "Double Invert Right Commute" );
          insert( new Reng( n1 , e0 ) );
end




// This simplification has a parallel implementation in SymbolicZero.negate()
rule "Negate Zero"
      when
          ez : SymbolicZero( )
          n1 : SymbolicNegate( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Negate Zero" );
          insert( new Reng( n1 , ez ) );
end




// This simplification has a parallel implementation in SymbolicZero.add()
rule "Add Zero A"
      when
          ez : SymbolicZero( )
          add1 : SymbolicAdd( elemA == ez )
          elB : SymbolicElem() from add1.getElemB()
          not( Reng( strt == add1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Add Zero A" );
          insert( new Reng( add1 , elB ) );
end




// This simplification has a parallel implementation in SymbolicElem.add()
rule "Add Zero B"
      when
          ez : SymbolicZero( )
          add1 : SymbolicAdd( elemB == ez )
          elA : SymbolicElem() from add1.getElemA()
          not( Reng( strt == add1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Add Zero B" );
          insert( new Reng( add1 , elA ) );
end





// This simplification has a parallel implementation in SymbolicIdentity.mult()
rule "Mult Ident A"
      when
          ez : SymbolicIdentity( )
          mult1 : SymbolicMult( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Ident A" );
          insert( new Reng( mult1 , elB ) );
end




rule "Mult Ident B"
      when
          ez : SymbolicIdentity( )
          mult1 : SymbolicMult( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
          eval( !( elA.exposesDerivatives() ) )
      then
          // System.out.println( "Mult Ident B" );
          insert( new Reng( mult1 , elA ) );
end





// This simplification has a parallel implementation in SymbolicZero.mult()
rule "Mult Zero A"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicMult( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Zero A" );
          insert( new Reng( mult1 , ez ) );
end





// This simplification has a parallel implementation in SymbolicElem.mult()
rule "Mult Zero B"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicMult( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Zero B" );
          insert( new Reng( mult1 , ez ) );
end





rule "Mult Over Negate A"
      when
          na : SymbolicNegate( )
          mult1 : SymbolicMult( elemA == na )
          a : SymbolicElem() from na.getElem()
          b : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == na ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over Negate A" );
          insert( new Reng( mult1 , a.mult( b ).insSym( ds ).negate().insSym( ds ) ) );
end




rule "Mult Over Negate B"
      when
          nb : SymbolicNegate( )
          mult1 : SymbolicMult( elemB == nb )
          a : SymbolicElem() from mult1.getElemA()
          b : SymbolicElem() from nb.getElem()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nb ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over Negate B" );
          insert( new Reng( mult1 , a.mult( b ).insSym( ds ).negate().insSym( ds ) ) );
end






rule "Mult Over DivideBy A"
      when
          na : SymbolicDivideBy( )
          mult1 : SymbolicMult( elemA == na )
          a : SymbolicElem() from na.getElem()
          b : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == na ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over DivideBy A" );
          insert( new Reng( mult1 , new SymbolicDivideBy( a.mult( b ).insSym( ds ) , na.getFac().getFac() , na.getIval() , ds ) ) );
end




rule "Mult Over DivideBy B"
      when
          nb : SymbolicDivideBy( )
          mult1 : SymbolicMult( elemB == nb )
          a : SymbolicElem() from mult1.getElemA()
          b : SymbolicElem() from nb.getElem()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nb ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over DivideBy B" );
          insert( new Reng( mult1 , new SymbolicDivideBy( a.mult( b ).insSym( ds ) , nb.getFac().getFac() , nb.getIval() , ds ) ) );
end






rule "Negate Over Add"
      when
          c : SymbolicAdd( )
          d : SymbolicNegate( elem == c )
          a : SymbolicElem() from c.getElemA()
          b : SymbolicElem() from c.getElemB()
          not( Reng( strt == d ) )
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "Negate Over Add" );
          insert( new Reng( d , a.negate().insSym( ds ).add( b.negate().insSym( ds ) ).insSym( ds ) ) );
end





rule "DivideBy Over Add"
      when
          c : SymbolicAdd( )
          d : SymbolicDivideBy( elem == c )
          a : SymbolicElem() from c.getElemA()
          b : SymbolicElem() from c.getElemB()
          not( Reng( strt == d ) )
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "DivideBy Over Add" );
          insert( new Reng( d , new SymbolicAdd( new SymbolicDivideBy( a , d.getFac().getFac() , d.getIval() , ds ) , new SymbolicDivideBy( b , d.getFac().getFac() , d.getIval() , ds ) , c.getFac().getFac() , ds ) ) );
end





rule "DivideBy Over Negate"
      when
          b : SymbolicNegate( )
          c : SymbolicDivideBy( elem == b )
          a : SymbolicElem() from b.getElem()
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "DivideBy Over Negate" );
          insert( new Reng( c , new SymbolicNegate( new SymbolicDivideBy( a , c.getFac().getFac() , c.getIval() , ds ) , b.getFac().getFac() , ds ) ) );
end










rule "Distribute InvertLeft Over Mult"
      when
          elm : SymbolicMult()
          el0 : SymbolicInvertLeft( elem == elm )
          a : SymbolicElem() from elm.getElemA()
          b : SymbolicElem() from elm.getElemB()
          not( Reng( strt == el0 ) )
          not( Reng( strt == elm ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds: DroolsSession()
      then
         // System.out.println( "Distribute InvertLeft Over Mult" );
         insert( new Reng( el0 , new SymbolicMult( new SymbolicInvertLeft( b , el0.getFac().getFac() , ds ) , new SymbolicInvertLeft( a , el0.getFac().getFac() , ds ) , elm.getFac().getFac() , ds ) ) );
end










rule "Distribute InvertRight Over Mult"
      when
          elm : SymbolicMult()
          el0 : SymbolicInvertRight( elem == elm )
          a : SymbolicElem() from elm.getElemA()
          b : SymbolicElem() from elm.getElemB()
          not( Reng( strt == el0 ) )
          not( Reng( strt == elm ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds: DroolsSession()
      then
         // System.out.println( "Distribute InvertRight Over Mult" );
         insert( new Reng( el0 , new SymbolicMult( new SymbolicInvertRight( b , el0.getFac().getFac() , ds ) , new SymbolicInvertRight( a , el0.getFac().getFac() , ds ) , elm.getFac().getFac() , ds ) ) );
end













rule "InvertLeft Over Negative"
      when
          el1 : SymbolicNegate( )
          el0 : SymbolicInvertLeft( elem == el1 )
          e0 : SymbolicElem() from el1.getElem()
          not( Reng( strt == el0 ) )
          not( Reng( strt == el1 ) )
          not( Reng( strt == e0 ) )
          ds: DroolsSession()
      then
         // System.out.println( "InvertLeft Over Negate" );
         insert( new Reng( el0 , new SymbolicNegate( new SymbolicInvertLeft( e0 , el0.getFac().getFac() , ds ) , el1.getFac().getFac() , ds ) ) );
end










rule "InvertRight Over Negative"
      when
          el1 : SymbolicNegate( )
          el0 : SymbolicInvertRight( elem == el1 )
          e0 : SymbolicElem() from el1.getElem()
          not( Reng( strt == el0 ) )
          not( Reng( strt == el1 ) )
          not( Reng( strt == e0 ) )
          ds: DroolsSession()
      then
         // System.out.println( "InvertRight Over Negate" );
         insert( new Reng( el0 , new SymbolicNegate( new SymbolicInvertRight( e0 , el0.getFac().getFac() , ds ) , el1.getFac().getFac() , ds ) ) );
end







rule "Partial Derivative Of Constant A --> Zero"
      when
          pd : PartialDerivativeOp( )
          red : SymbolicReduction( )
          mult : SymbolicMult( elemA == pd , elemB == red )
          not( Reng( strt == mult ) )
          not( Reng( strt == red ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( red.partialDerivativeReducesToZero( pd.getWithRespectTo() ) )
      then
         // System.out.println( "Partial Derivative Of Constant A --> Zero" );
         insert( new Reng( mult , new SymbolicZero( mult.getFac().getFac() , ds ) ) );
end






// This simplification has a parallel implementation in SymbolicZero.divideBy()
rule "DivideBy OF Zero --> Zero"
      when
          a : SymbolicZero( )
          b : SymbolicDivideBy( elem == a )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
          eval( b.divNotZero() )
      then
          // System.out.println( "DivideBy OF Zero --> Zero" );
          insert( new Reng( b , a ) );
end






// This simplification has a parallel implementation in SymbolicZero.random()
rule "Random OF Zero --> Zero"
      when
          a : SymbolicZero( )
          b : SymbolicRandom( elem == a )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "Random OF Zero --> Zero" );
          insert( new Reng( b , a ) );
end





// This simplification has a parallel implementation in SymbolicDivideBy.divideBy()
rule "Double DivideBy"
     when
          n0 : SymbolicDivideBy( )
          n1 : SymbolicDivideBy( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
          ds : DroolsSession()
     then
          // System.out.println( "Double DivideBy" );
          insert( new Reng( n1 , new SymbolicDivideBy( e0 , n0.getFac() , n0.getIval().multiply( n1.getIval() ) , ds ) ) );
end






rule "Partial Derivative Of Constant B --> Zero"
      when
          pd : PartialDerivativeOp( )
          mult : SymbolicMult( elemA == pd )
          cn : SymbolicElem() from mult.getElemB()
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Partial Derivative Of Constant B --> Zero" );
         insert( new Reng( mult , new SymbolicZero( cn.getFac() , ds ) ) );
end








// This simplification has a parallel implementation in SymbolicIdentity.invertLeft()
rule "Invert Left Identity --> Identity"
      when
          ez : SymbolicIdentity( )
          n1 : SymbolicInvertLeft( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Invert Left Identity --> Identity" );
          insert( new Reng( n1 , ez ) );
end








// This simplification has a parallel implementation in SymbolicIdentity.invertRight()
rule "Invert Right Identity --> Identity"
      when
          ez : SymbolicIdentity( )
          n1 : SymbolicInvertRight( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Invert Right Identity --> Ientity" );
          insert( new Reng( n1 , ez ) );
end






rule "Mult Negative Ident A"
      when
          ez : SymbolicIdentity( )
          nnez : SymbolicNegate( elem == ez )
          mult1 : SymbolicMult( elemA == nnez )
          nez : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nez ) )
          not( Reng( strt == nnez ) )
          not( Reng( strt == ez ) )
          not( eval( nez instanceof SymbolicNegate ) )
      then
          // System.out.println( "Mult Negative Ident A" );
          insert( new Reng( mult1 , nez.negate() ) );
end




rule "Mult Negative Ident B"
      when
          ez : SymbolicIdentity( )
          nnez : SymbolicNegate( elem == ez )
          mult1 : SymbolicMult( elemB == nnez )
          nez : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nez ) )
          not( Reng( strt == nnez ) )
          not( Reng( strt == ez ) )
          not( eval( nez instanceof SymbolicNegate ) )
          eval( !( nez.exposesDerivatives() ) )
      then
          // System.out.println( "Mult Negative Ident B" );
          insert( new Reng( mult1 , nez.negate() ) );
end





rule "SymbolicReduction Zero"
      when
          ez : Elem( )
          tr1 : SymbolicReduction( elem == ez )
          eval( ez.evalSymbolicZeroApprox( SymbolicElem.EVAL_MODE.SIMPLIFY2 ) )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == ez ) )
          ds : DroolsSession()
      then
          // System.out.println( "SymbolicReduction Zero" );
          insert( new Reng( tr1 , tr1.getFac().zero().insSym( ds ) ) );
end





rule "SymbolicReduction Identity"
      when
          ident : Elem( )
          tr1 : SymbolicReduction( elem == ident )
          eval( ident.evalSymbolicIdentityApprox( SymbolicElem.EVAL_MODE.SIMPLIFY2 ) )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == ident ) )
          ds : DroolsSession()
      then
          // System.out.println( "SymbolicReduction Identity" );
          insert( new Reng( tr1 , tr1.getFac().identity().insSym( ds ) ) );
end





rule "SymbolicSqrt Identity"
      when
          ident : SymbolicIdentity( )
          tr1 : SymbolicSqrt( elem == ident )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == ident ) )
          ds : DroolsSession()
      then
          // System.out.println( "SymbolicSqrt Identity" );
          insert( new Reng( tr1 , ident ) );
end





rule "Exponential Of Zero --> Identity"
      when
          a : SymbolicZero( )
          b : SymbolicExponential( elem == a )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "Exponential Of Zero --> Identity" );
          insert( new Reng( b , new SymbolicIdentity( a.getFac().getFac() , ds ) ) );
end





rule "Sine Of Zero --> Zero"
      when
          a : SymbolicZero( )
          b : SymbolicSine( elem == a )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "Sine Of Zero --> Identity" );
          insert( new Reng( b , a ) );
end





rule "Cosine Of Zero --> Identity"
      when
          a : SymbolicZero( )
          b : SymbolicCosine( elem == a )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "Cosine Of Zero --> Identity" );
          insert( new Reng( b , new SymbolicIdentity( a.getFac().getFac() , ds ) ) );
end





rule "Transpose Zero"
      when
          ez : SymbolicZero( )
          tr1 : SymbolicTranspose( elem == ez )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Transpose Zero" );
          insert( new Reng( tr1 , ez ) );
end





rule "Transpose Identity"
      when
          iden : SymbolicIdentity( )
          tr1 : SymbolicTranspose( elem == iden )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == iden ) )
      then
          // System.out.println( "Transpose Identity" );
          insert( new Reng( tr1 , iden ) );
end





rule "Transpose Over Negate"
      when
          na : SymbolicNegate( )
          tr1 : SymbolicTranspose( elem == na )
          a : SymbolicElem() from na.getElem()
          not( Reng( strt == tr1 ) )
          not( Reng( strt == na ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "Transpose Over Negate" );
          insert( new Reng( tr1 , ( new SymbolicTranspose( a , (SquareMatrixElemFactory)( tr1.getFac().getFac() ) , ds ) ).negate().insSym( ds ) ) );
end





rule "Invert Left Rev Coeff Identity"
      when
          iden : SymbolicIdentity( )
          tr1 : SymbolicInvertLeftRevCoeff( elem == iden )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == iden ) )
      then
          // System.out.println( "Invert Left Rev Coeff Identity" );
          insert( new Reng( tr1 , iden ) );
end





rule "Invert Right Rev Coeff Identity"
      when
          iden : SymbolicIdentity( )
          tr1 : SymbolicInvertRightRevCoeff( elem == iden )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == iden ) )
      then
          // System.out.println( "Invert Right Rev Coeff Identity" );
          insert( new Reng( tr1 , iden ) );
end





rule "MultRevCoeff Zero A"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicMultRevCoeff( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "MultRevCoeff Zero A" );
          insert( new Reng( mult1 , ez ) );
end





rule "MultRevCoeff Zero B"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicMultRevCoeff( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "MultRevCoeff Zero B" );
          insert( new Reng( mult1 , ez ) );
end






rule "MultRevCoeff Ident A"
      when
          ez : SymbolicIdentity( )
          mult1 : SymbolicMultRevCoeff( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
          eval( !( elB.exposesDerivatives() ) )
      then
          // System.out.println( "MultRevCoeff Ident A" );
          insert( new Reng( mult1 , elB ) );
end




rule "MultRevCoeff Ident B"
      when
          ez : SymbolicIdentity( )
          mult1 : SymbolicMultRevCoeff( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "MultRevCoeff Ident B" );
          insert( new Reng( mult1 , elA ) );
end





rule "Conjugate Left Identity"
      when
          iden : SymbolicIdentity( )
          tr1 : SymbolicConjugateLeft( elem == iden )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == iden ) )
      then
          // System.out.println( "Conjugate Left Identity" );
          insert( new Reng( tr1 , iden ) );
end





rule "Conjugate Right Identity"
      when
          iden : SymbolicIdentity( )
          tr1 : SymbolicConjugateRight( elem == iden )
          not( Reng( strt == tr1 ) )
          not( Reng( strt == iden ) )
      then
          // System.out.println( "Conjugate Right Identity" );
          insert( new Reng( tr1 , iden ) );
end





rule "Wedge Zero A"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicWedge( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Wedge Zero A" );
          insert( new Reng( mult1 , ez ) );
end





rule "Wedge Zero B"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicWedge( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Wedge Zero B" );
          insert( new Reng( mult1 , ez ) );
end







rule "Dot Zero A"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicDot( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Dot Zero A" );
          insert( new Reng( mult1 , ez ) );
end





rule "Dot Zero B"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicDot( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Dot Zero B" );
          insert( new Reng( mult1 , ez ) );
end







rule "Dot Hestenes Zero A"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicDotHestenes( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Dot Hestenes Zero A" );
          insert( new Reng( mult1 , ez ) );
end





rule "Dot Hestenes Zero B"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicDotHestenes( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Dot Hestenes Zero B" );
          insert( new Reng( mult1 , ez ) );
end







rule "Scalar Product Zero A"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicScalar( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Scalar Product Zero A" );
          insert( new Reng( mult1 , ez ) );
end





rule "Scalar Product Zero B"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicScalar( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Scalar Product Zero B" );
          insert( new Reng( mult1 , ez ) );
end





rule "ReverseLeft Identity"
      when
          ident : SymbolicIdentity( )
          mult1 : SymbolicReverseLeft( elemA == ident )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == ident ) )
      then
          // System.out.println( "ReverseLeft Identity" );
          insert( new Reng( mult1 , ident ) );
end





rule "ReverseRight Identity"
      when
          ident : SymbolicIdentity( )
          mult1 : SymbolicReverseRight( elemA == ident )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == ident ) )
      then
          // System.out.println( "ReverseRight Identity" );
          insert( new Reng( mult1 , ident ) );
end





rule "Symbolic Index Reduction Zero"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicIndexReduction( elem == ez )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Symbolic Index Reduction Zero" );
          insert( new Reng( mult1 , ez ) );
end







rule "Directional Derivative Of Constant --> Zero"
      when
          pd : DirectionalDerivative( )
          mult : SymbolicMult( elemA == pd )
          cn : SymbolicElem() from mult.getElemB()
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Directional Derivative Of Constant --> Zero" );
         insert( new Reng( mult , new SymbolicZero( cn.getFac() , ds ) ) );
end







rule "Directional Derivative Dot Constant --> Zero"
      when
          pd : DirectionalDerivative( )
          mult : SymbolicDot( elemA == pd )
          cn : SymbolicElem() from mult.getElemB()
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Directional Derivative Dot Constant --> Zero" );
         insert( new Reng( mult , new SymbolicZero( cn.getFac() , ds ) ) );
end







rule "Directional Derivative DotHestenes Constant --> Zero"
      when
          pd : DirectionalDerivative( )
          mult : SymbolicDotHestenes( elemA == pd )
          cn : SymbolicElem() from mult.getElemB()
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Directional Derivative DotHestenes Constant --> Zero" );
         insert( new Reng( mult , new SymbolicZero( cn.getFac() , ds ) ) );
end







rule "Directional Derivative Wedge Constant --> Zero"
      when
          pd : DirectionalDerivative( )
          mult : SymbolicWedge( elemA == pd )
          cn : SymbolicElem() from mult.getElemB()
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Directional Derivative Wedge Constant --> Zero" );
         insert( new Reng( mult , new SymbolicZero( cn.getFac() , ds ) ) );
end







rule "Directional Derivative Cross Constant --> Zero"
      when
          pd : DirectionalDerivative( )
          mult : SymbolicCross( elemA == pd )
          cn : SymbolicElem() from mult.getElemB()
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Directional Derivative Cross Constant --> Zero" );
         insert( new Reng( mult , new SymbolicZero( cn.getFac() , ds ) ) );
end







rule "Directional Derivative Scalar-Product Constant --> Zero"
      when
          pd : DirectionalDerivative( )
          mult : SymbolicScalar( elemA == pd )
          cn : SymbolicElem() from mult.getElemB()
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Directional Derivative Scalar-Product Constant --> Zero" );
         insert( new Reng( mult , new SymbolicZero( cn.getFac() , ds ) ) );
end




















