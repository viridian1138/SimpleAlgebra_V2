

//$$strtCprt
//
// Simple Algebra 
// 
// Copyright (C) 2014 Thornton Green
// 
// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with this program; if not, 
// see <http://www.gnu.org/licenses>.
// Additional permission under GNU GPL version 3 section 7
//
//
//$$endCprt

package simplealgebra.symbolic




import simplealgebra.ddx.PartialDerivativeOp;
import simplealgebra.ga.SymbolicReverseLeft;
import simplealgebra.ga.SymbolicReverseRight;
import simplealgebra.ga.SymbolicDot;
import simplealgebra.ga.SymbolicWedge;
import simplealgebra.ga.GeometricAlgebraMultivectorElemFactory;






rule "Apply Placeholder"
     when
          r0 : Reng( )
          p : SymbolicPlaceholder( elem == r0.getStrt() )
     then
          // System.out.println( "Apply Placeholder" );
          modify( p ){ setElem( r0.getEnd() ) };
end






rule "Apply Negate"
     when
          r0 : Reng( )
          p : SymbolicNegate( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Negate" );
          insert( new Reng( p , r0.getEnd().negate().insSym( ds ) ) );
end






rule "Apply Absolute Value"
     when
          r0 : Reng( )
          p : SymbolicAbsoluteValue( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Absolute Value" );
          insert( new Reng( p , new SymbolicAbsoluteValue( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end







rule "Apply Invert Left"
     when
          r0 : Reng( )
          p : SymbolicInvertLeft( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Invert Left" );
          insert( new Reng( p , new SymbolicInvertLeft( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end







rule "Apply Invert Right"
     when
          r0 : Reng( )
          p : SymbolicInvertRight( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Invert Right" );
          insert( new Reng( p , new SymbolicInvertRight( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end








rule "Apply Reverse Left"
     when
          r0 : Reng( )
          p : SymbolicReverseLeft( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Reverse Left" );
          insert( new Reng( p , new SymbolicReverseLeft( r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end







rule "Apply Reverse Right"
     when
          r0 : Reng( )
          p : SymbolicReverseRight( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Reverse Right" );
          insert( new Reng( p , new SymbolicReverseRight( r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end








rule "Apply Divide By"
     when
          r0 : Reng( )
          p : SymbolicDivideBy( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Divide By" );
          insert( new Reng( p , new SymbolicDivideBy( r0.getEnd() , p.getFac().getFac() , p.getIval() , ds ) ) );
end








rule "Apply Mutable"
     when
          r0 : Reng( )
          p : SymbolicMutable( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Mutable" );
          insert( new Reng( p , new SymbolicMutable( r0.getEnd() , p.getElemB() , p.getFac().getFac() , ds ) ) );
end








rule "Apply AddA"
     when
          r0 : Reng( )
          p : SymbolicAdd( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply AddA" );
          insert( new Reng( p , r0.getEnd().add( p.getElemB() ).insSym( ds ) ) );
end





rule "Apply AddB"
     when
          r0 : Reng( )
          p : SymbolicAdd( elemB == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply AddB" );
          insert( new Reng( p , p.getElemA().add( r0.getEnd() ).insSym( ds ) ) );
end





rule "Apply MultA"
     when
          r0 : Reng( )
          p : SymbolicMult( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply MultA" );
          insert( new Reng( p , r0.getEnd().mult( p.getElemB() ).insSym( ds ) ) );
end





rule "Apply MultB"
     when
          r0 : Reng( )
          p : SymbolicMult( elemB == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply MultB" );
          insert( new Reng( p , p.getElemA().mult( r0.getEnd() ).insSym( ds ) ) );
end






rule "Apply DotA"
     when
          r0 : Reng( )
          p : SymbolicDot( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply DotA" );
          insert( new Reng( p , new SymbolicDot( r0.getEnd() , p.getElemB() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end





rule "Apply DotB"
     when
          r0 : Reng( )
          p : SymbolicDot( elemB == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply DotB" );
          insert( new Reng( p , new SymbolicDot( p.getElemA() , r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end








rule "Apply WedgeA"
     when
          r0 : Reng( )
          p : SymbolicWedge( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply WedgeA" );
          insert( new Reng( p , new SymbolicWedge( r0.getEnd() , p.getElemB() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end





rule "Apply WedgeB"
     when
          r0 : Reng( )
          p : SymbolicWedge( elemB == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply WedgeB" );
          insert( new Reng( p , new SymbolicWedge( p.getElemA() , r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end





// This simplification has a parallel implementation in SymbolicZero.negate()
rule "Double Negate"
     when
          n0 : SymbolicNegate( )
          n1 : SymbolicNegate( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == n0.getElem() ) )
     then
          // System.out.println( "Double Negate" );
          insert( new Reng( n1 , n0.getElem() ) );
end






rule "Double Absolute Value"
     when
          n0 : SymbolicAbsoluteValue( )
          n1 : SymbolicAbsoluteValue( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
     then
          // System.out.println( "Double Absolute Value" );
          insert( new Reng( n1 , n0 ) );
end







rule "Double Invert Left NonCommute"
     when
          n0 : SymbolicInvertLeft( )
          n1 : SymbolicInvertRight( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == n0.getElem() ) )
     then
          // System.out.println( "Double Invert Left NonCommute" );
          insert( new Reng( n1 , n0.getElem() ) );
end






rule "Double Invert Right NonCommute"
     when
          n0 : SymbolicInvertRight( )
          n1 : SymbolicInvertLeft( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == n0.getElem() ) )
     then
          // System.out.println( "Double Invert Right NonCommute" );
          insert( new Reng( n1 , n0.getElem() ) );
end






rule "Double Invert Left Commute"
     when
          n0 : SymbolicInvertLeft( )
          n1 : SymbolicInvertLeft( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == n0.getElem() ) )
          eval( n0.getElem().getFac().isNestedMultCommutative() )
     then
          // System.out.println( "Double Invert Left Commute" );
          insert( new Reng( n1 , n0.getElem() ) );
end






rule "Double Invert Right Commute"
     when
          n0 : SymbolicInvertRight( )
          n1 : SymbolicInvertRight( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == n0.getElem() ) )
          eval( n0.getElem().getFac().isNestedMultCommutative() )
     then
          // System.out.println( "Double Invert Right Commute" );
          insert( new Reng( n1 , n0.getElem() ) );
end




// This simplification has a parallel implementation in SymbolicZero.negate()
rule "Negate Zero"
      when
          ez : SymbolicZero( )
          n1 : SymbolicNegate( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Negate Zero" );
          insert( new Reng( n1 , ez ) );
end




// This simplification has a parallel implementation in SymbolicZero.add()
rule "Add Zero A"
      when
          ez : SymbolicZero( )
          add1 : SymbolicAdd( elemA == ez )
          not( Reng( strt == add1 ) )
          not( Reng( strt == add1.getElemB() ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Add Zero A" );
          insert( new Reng( add1 , add1.getElemB() ) );
end




// This simplification has a parallel implementation in SymbolicElem.add()
rule "Add Zero B"
      when
          ez : SymbolicZero( )
          add1 : SymbolicAdd( elemB == ez )
          not( Reng( strt == add1 ) )
          not( Reng( strt == add1.getElemA() ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Add Zero B" );
          insert( new Reng( add1 , add1.getElemA() ) );
end





// This simplification has a parallel implementation in SymbolicIdentity.mult()
rule "Mult Ident A"
      when
          ez : SymbolicIdentity( )
          mult1 : SymbolicMult( elemA == ez )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == mult1.getElemB() ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Ident A" );
          insert( new Reng( mult1 , mult1.getElemB() ) );
end




rule "Mult Ident B"
      when
          ez : SymbolicIdentity( )
          mult1 : SymbolicMult( elemB == ez )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == mult1.getElemA() ) )
          not( Reng( strt == ez ) )
          eval( !( mult1.getElemA().exposesDerivatives() ) )
      then
          // System.out.println( "Mult Ident B" );
          insert( new Reng( mult1 , mult1.getElemA() ) );
end





// This simplification has a parallel implementation in SymbolicZero.mult()
rule "Mult Zero A"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicMult( elemA == ez )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == mult1.getElemB() ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Zero A" );
          insert( new Reng( mult1 , ez ) );
end





// This simplification has a parallel implementation in SymbolicElem.mult()
rule "Mult Zero B"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicMult( elemB == ez )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == mult1.getElemA() ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Zero B" );
          insert( new Reng( mult1 , ez ) );
end





rule "Mult Over Negate A"
      when
          na : SymbolicNegate( )
          mult1 : SymbolicMult( elemA == na )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == na ) )
          not( Reng( strt == na.getElem() ) )
          not( Reng( strt == mult1.getElemB() ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over Negate A" );
          insert( new Reng( mult1 , na.getElem().mult( mult1.getElemB() ).insSym( ds ).negate().insSym( ds ) ) );
end




rule "Mult Over Negate B"
      when
          nb : SymbolicNegate( )
          mult1 : SymbolicMult( elemB == nb )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nb ) )
          not( Reng( strt == mult1.getElemA() ) )
          not( Reng( strt == nb.getElem() ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over Negate B" );
          insert( new Reng( mult1 , mult1.getElemA().mult( nb.getElem() ).insSym( ds ).negate().insSym( ds ) ) );
end






rule "Mult Over DivideBy A"
      when
          na : SymbolicDivideBy( )
          mult1 : SymbolicMult( elemA == na )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == na ) )
          not( Reng( strt == na.getElem() ) )
          not( Reng( strt == mult1.getElemB() ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over DivideBy A" );
          insert( new Reng( mult1 , new SymbolicDivideBy( na.getElem().mult( mult1.getElemB() ).insSym( ds ) , na.getFac().getFac() , na.getIval() , ds ) ) );
end




rule "Mult Over DivideBy B"
      when
          nb : SymbolicDivideBy( )
          mult1 : SymbolicMult( elemB == nb )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nb ) )
          not( Reng( strt == mult1.getElemA() ) )
          not( Reng( strt == nb.getElem() ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over DivideBy B" );
          insert( new Reng( mult1 , new SymbolicDivideBy( mult1.getElemA().mult( nb.getElem() ).insSym( ds ) , nb.getFac().getFac() , nb.getIval() , ds ) ) );
end






rule "Negate Over Add"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          c : SymbolicAdd( elemA == a , elemB == b )
          d : SymbolicNegate( elem == c )
          not( Reng( strt == d ) )
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "Negate Over Add" );
          insert( new Reng( d , a.negate().insSym( ds ).add( b.negate().insSym( ds ) ).insSym( ds ) ) );
end





rule "DivideBy Over Add"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          c : SymbolicAdd( elemA == a , elemB == b )
          d : SymbolicDivideBy( elem == c )
          not( Reng( strt == d ) )
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "DivideBy Over Add" );
          insert( new Reng( d , new SymbolicAdd( new SymbolicDivideBy( a , d.getFac().getFac() , d.getIval() , ds ) , new SymbolicDivideBy( b , d.getFac().getFac() , d.getIval() , ds ) , c.getFac().getFac() , ds ) ) );
end





rule "DivideBy Over Negate"
      when
          a : SymbolicElem( )
          b : SymbolicNegate( elem == a )
          c : SymbolicDivideBy( elem == b )
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "DivideBy Over Negate" );
          insert( new Reng( c , new SymbolicNegate( new SymbolicDivideBy( a , c.getFac().getFac() , c.getIval() , ds ) , b.getFac().getFac() , ds ) ) );
end










rule "Distribute InvertLeft Over Mult"
      when
          elm : SymbolicMult()
          el0 : SymbolicInvertLeft( elem == elm )
          not( Reng( strt == el0 ) )
          not( Reng( strt == elm ) )
          ds: DroolsSession()
      then
         // System.out.println( "Distribute InvertLeft Over Mult" );
         insert( new Reng( el0 , new SymbolicMult( new SymbolicInvertLeft( elm.getElemB() , el0.getFac().getFac() , ds ) , new SymbolicInvertLeft( elm.getElemA() , el0.getFac().getFac() , ds ) , elm.getFac().getFac() , ds ) ) );
end










rule "Distribute InvertRight Over Mult"
      when
          elm : SymbolicMult()
          el0 : SymbolicInvertRight( elem == elm )
          not( Reng( strt == el0 ) )
          not( Reng( strt == elm ) )
          ds: DroolsSession()
      then
         // System.out.println( "Distribute InvertRight Over Mult" );
         insert( new Reng( el0 , new SymbolicMult( new SymbolicInvertRight( elm.getElemB() , el0.getFac().getFac() , ds ) , new SymbolicInvertRight( elm.getElemA() , el0.getFac().getFac() , ds ) , elm.getFac().getFac() , ds ) ) );
end













rule "InvertLeft Over Negative"
      when
          elm : SymbolicElem()
          el1 : SymbolicNegate( elem == elm )
          el0 : SymbolicInvertLeft( elem == el1 )
          not( Reng( strt == el0 ) )
          not( Reng( strt == el1 ) )
          not( Reng( strt == elm ) )
          ds: DroolsSession()
      then
         // System.out.println( "InvertLeft Over Negate" );
         insert( new Reng( el0 , new SymbolicNegate( new SymbolicInvertLeft( elm , el0.getFac().getFac() , ds ) , el1.getFac().getFac() , ds ) ) );
end










rule "InvertRight Over Negative"
      when
          elm : SymbolicElem()
          el1 : SymbolicNegate( elem == elm )
          el0 : SymbolicInvertRight( elem == el1 )
          not( Reng( strt == el0 ) )
          not( Reng( strt == el1 ) )
          not( Reng( strt == elm ) )
          ds: DroolsSession()
      then
         // System.out.println( "InvertRight Over Negate" );
         insert( new Reng( el0 , new SymbolicNegate( new SymbolicInvertRight( elm , el0.getFac().getFac() , ds ) , el1.getFac().getFac() , ds ) ) );
end







rule "Partial Derivative Of Constant A --> Zero"
      when
          pd : PartialDerivativeOp( )
          red : SymbolicReduction( )
          mult : SymbolicMult( elemA == pd , elemB == red )
          not( Reng( strt == mult ) )
          not( Reng( strt == red ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( red.partialDerivativeReducesToZero( pd.getWithRespectTo() ) )
      then
         // System.out.println( "Partial Derivative Of Constant A --> Zero" );
         insert( new Reng( mult , new SymbolicZero( mult.getFac().getFac() , ds ) ) );
end






// This simplification has a parallel implementation in SymbolicZero.divideBy()
rule "DivideBy OF Zero --> Zero"
      when
          a : SymbolicZero( )
          b : SymbolicDivideBy( elem == a )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
          eval( b.divNotZero() )
      then
          // System.out.println( "DivideBy OF Zero --> Zero" );
          insert( new Reng( b , a ) );
end






// This simplification has a parallel implementation in SymbolicDivideBy.divideBy()
rule "Double DivideBy"
     when
          n0 : SymbolicDivideBy( )
          n1 : SymbolicDivideBy( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == n0.getElem() ) )
          ds : DroolsSession()
     then
          // System.out.println( "Double DivideBy" );
          insert( new Reng( n1 , new SymbolicDivideBy( n0.getElem() , n0.getFac() , n0.getIval().multiply( n1.getIval() ) , ds ) ) );
end






rule "Partial Derivative Of Constant B --> Zero"
      when
          pd : PartialDerivativeOp( )
          cn : SymbolicElem( )
          mult : SymbolicMult( elemA == pd , elemB == cn )
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Partial Derivative Of Constant B --> Zero" );
         insert( new Reng( mult , cn ) );
end








// This simplification has a parallel implementation in SymbolicIdentity.invertLeft()
rule "Invert Left Identity --> Identity"
      when
          ez : SymbolicIdentity( )
          n1 : SymbolicInvertLeft( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Invert Left Identity --> Identity" );
          insert( new Reng( n1 , ez ) );
end








// This simplification has a parallel implementation in SymbolicIdentity.invertRight()
rule "Invert Right Identity --> Identity"
      when
          ez : SymbolicIdentity( )
          n1 : SymbolicInvertRight( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Invert Right Identity --> Ientity" );
          insert( new Reng( n1 , ez ) );
end






rule "Mult Negative Ident A"
      when
          ez : SymbolicIdentity( )
          nnez : SymbolicNegate( elem == ez )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == nnez , elemB == nez )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nez ) )
          not( Reng( strt == nnez ) )
          not( Reng( strt == ez ) )
          not( eval( nez instanceof SymbolicNegate ) )
      then
          // System.out.println( "Mult Negative Ident A" );
          insert( new Reng( mult1 , nez.negate() ) );
end




rule "Mult Negative Ident B"
      when
          ez : SymbolicIdentity( )
          nnez : SymbolicNegate( elem == ez )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == nez , elemB == nnez )
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nez ) )
          not( Reng( strt == nnez ) )
          not( Reng( strt == ez ) )
          eval( !( nez.exposesDerivatives() ) )
          not( eval( nez instanceof SymbolicNegate ) )
      then
          // System.out.println( "Mult Negative Ident B" );
          insert( new Reng( mult1 , nez.negate() ) );
end
















