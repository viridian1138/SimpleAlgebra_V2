




//$$strtCprt
/**
* Simple Algebra 
* 
* Copyright (C) 2014 Thornton Green
* 
* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
* You should have received a copy of the GNU General Public License along with this program; if not, 
* see <http://www.gnu.org/licenses>.
* Additional permission under GNU GPL version 3 section 7
*
*/
//$$endCprt






package test_simplealgebra.run3d_a;



import java.io.FileReader;
import java.io.InputStreamReader;
import java.io.LineNumberReader;
import java.util.Random;

import junit.framework.TestCase;


/**
 * Tests the ability to load text files for a 3-D TensorFlow neural-net model for slope estimation from NNFSA (Neural-Net Generator For Simple Algebra) and evaluates the neural-net for a random input.
 * 
 * Note: the wvals and bvals files loaded by this class are not checked-in, but are instead generated by the runExport3d_a.sh script in NNFSA.
 * 
 * This documentation should be viewed using Firefox version 33.1.1 or above.
 * 
 * @author tgreen
 *
 */
public class TestLoad3D extends TestCase {

	

	
	/**
	 * Node representing a TensorFlow-generated neural network.
	 * 
	 * @author tgreen
	 *
	 */
	protected static class NeuralNode
	{
		protected double[][] wvals_h1;
		protected double[][] wvals_h2;
		protected double[][] wvals_h3;
		protected double[][] wvals_h4;
		protected double[][] wvals_out;
	
	
		protected double[] bvals_h1;
		protected double[] bvals_h2;
		protected double[] bvals_h3;
		protected double[] bvals_h4;
		protected double[] bvals_out;
		
		
		protected double[] tvals_h1;
		protected double[] tvals_h2;
		protected double[] tvals_h3;
		protected double[] tvals_h4;
		
		
		/**
		 * Evaluates the neural network.
		 * @param in The neural network input values.
		 * @return The result of evaluationg the neural network.
		 */
		public double eval( final double[] in )
		{
			
			for( int i = 0 ; i < tvals_h1.length ; i++ )
			{
				tvals_h1[ i ] = 0.0;
			}
			
			
			for( int i = 0 ; i < in.length ; i++ )
			{
				for( int j = 0 ; j < tvals_h1.length ; j++ )
				{
					tvals_h1[ j ] += wvals_h1[ i ][ j ] * in[ i ];
				}
			}
			
			for( int i = 0 ; i < tvals_h1.length ; i++ )
			{
				tvals_h1[ i ] = Math.max( 0.0 , tvals_h1[ i ] + bvals_h1[ i ] );
			}
			
			
			for( int i = 0 ; i < tvals_h2.length ; i++ )
			{
				tvals_h2[ i ] = 0.0;
			}
			
			
			for( int i = 0 ; i < tvals_h1.length ; i++ )
			{
				for( int j = 0 ; j < tvals_h2.length ; j++ )
				{
					tvals_h2[ j ] += wvals_h2[ i ][ j ] * tvals_h1[ i ];
				}
			}
			
			for( int i = 0 ; i < tvals_h2.length ; i++ )
			{
				tvals_h2[ i ] = Math.max( 0.0 , tvals_h2[ i ] + bvals_h2[ i ] );
			}
			
			
			for( int i = 0 ; i < tvals_h3.length ; i++ )
			{
				tvals_h3[ i ] = 0.0;
			}
			
			
			for( int i = 0 ; i < tvals_h2.length ; i++ )
			{
				for( int j = 0 ; j < tvals_h3.length ; j++ )
				{
					tvals_h3[ j ] += wvals_h3[ i ][ j ] * tvals_h2[ i ];
				}
			}
			
			
			for( int i = 0 ; i < tvals_h3.length ; i++ )
			{
				tvals_h3[ i ] = Math.max( 0.0 , tvals_h3[ i ] + bvals_h3[ i ] );
			}
			
			
			for( int i = 0 ; i < tvals_h4.length ; i++ )
			{
				tvals_h4[ i ] = 0.0;
			}
			
			
			for( int i = 0 ; i < tvals_h3.length ; i++ )
			{
				for( int j = 0 ; j < tvals_h4.length ; j++ )
				{
					tvals_h4[ j ] += wvals_h4[ i ][ j ] * tvals_h3[ i ];
				}
			}
			
			
			for( int i = 0 ; i < tvals_h4.length ; i++ )
			{
				tvals_h4[ i ] = Math.max( 0.0 , tvals_h4[ i ] + bvals_h4[ i ] );
			}
			
			
			double out = 0.0;
			
			
			
			for( int i = 0 ; i < tvals_h4.length ; i++ )
			{
				out += wvals_out[ i ][ 0 ] * tvals_h4[ i ];
			}
			
			
			
			out = Math.max( 0.0 , out + bvals_out[ 0 ] );
			
			
			
			return( out );
			
			
			
		}
		
		
	}
	
	
	
	
	protected NeuralNode loadNeuralNode( String wfile , String bfile ) throws Throwable
	{
		NeuralNode node = new NeuralNode();
		
		{
			LineNumberReader li = new LineNumberReader( new InputStreamReader( this.getClass().getResourceAsStream( wfile ) ) );
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				final int maxJ = Integer.parseInt( li.readLine() );
				
				node.wvals_h1 = new double[ maxI ][ maxJ ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					for( int j = 0 ; j < maxJ ; j++ )
					{
						node.wvals_h1[ i ][ j ] = Double.parseDouble( li.readLine() );
					}
				}
				
			}
			
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				final int maxJ = Integer.parseInt( li.readLine() );
				
				node.wvals_h2 = new double[ maxI ][ maxJ ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					for( int j = 0 ; j < maxJ ; j++ )
					{
						node.wvals_h2[ i ][ j ] = Double.parseDouble( li.readLine() );
					}
				}
				
			}
			
			
			
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				final int maxJ = Integer.parseInt( li.readLine() );
				
				node.wvals_h3 = new double[ maxI ][ maxJ ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					for( int j = 0 ; j < maxJ ; j++ )
					{
						node.wvals_h3[ i ][ j ] = Double.parseDouble( li.readLine() );
					}
				}
				
			}
			
			
			
			
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				final int maxJ = Integer.parseInt( li.readLine() );
				
				node.wvals_h4 = new double[ maxI ][ maxJ ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					for( int j = 0 ; j < maxJ ; j++ )
					{
						node.wvals_h4[ i ][ j ] = Double.parseDouble( li.readLine() );
					}
				}
				
			}
			
			
			
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				final int maxJ = Integer.parseInt( li.readLine() );
				
				node.wvals_out = new double[ maxI ][ maxJ ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					for( int j = 0 ; j < maxJ ; j++ )
					{
						node.wvals_out[ i ][ j ] = Double.parseDouble( li.readLine() );
					}
				}
				
			}
			
			

			
		}
		
		
		
		
		
		
		{
			LineNumberReader li = new LineNumberReader( new InputStreamReader( this.getClass().getResourceAsStream( bfile ) ) );
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				
				node.bvals_h1 = new double[ maxI ];
				node.tvals_h1 = new double[ maxI ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					node.bvals_h1[ i ] = Double.parseDouble( li.readLine() );
				}
				
			}
			
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				
				node.bvals_h2 = new double[ maxI ];
				node.tvals_h2 = new double[ maxI ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					node.bvals_h2[ i ] = Double.parseDouble( li.readLine() );
				}
				
			}
			
			
			
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				
				node.bvals_h3 = new double[ maxI ];
				node.tvals_h3 = new double[ maxI ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					node.bvals_h3[ i ] = Double.parseDouble( li.readLine() );
				}
				
			}
			
			
			
			
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				
				node.bvals_h4 = new double[ maxI ];
				node.tvals_h4 = new double[ maxI ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					node.bvals_h4[ i ] = Double.parseDouble( li.readLine() );
				}
				
			}
			
			
			
			
			
			{
				
				li.readLine();
				
				final int maxI = Integer.parseInt( li.readLine() );
				
				node.bvals_out = new double[ maxI ];
				
				for( int i = 0 ; i < maxI ; i++ )
				{
					node.bvals_out[ i ] = Double.parseDouble( li.readLine() );
				}
				
			}
			
			

			
		}
		
		
		
		return( node );
		
	}
	
	
	
	
	protected NeuralNode[][][] nodes;

	
	
	
	
	protected void load3D() throws Throwable
	{
		
		
		nodes = new NeuralNode[ ( 2 * NSTPT + 1 ) ][ ( 2 * NSTPX + 1 ) ][ ( 2 * NSTPX + 1 ) ];
		
		
		final int[] cntrVals = { ( 2 * NSTPT + 1 ) - 1 , ( ( 2 * NSTPX + 1 ) - 1 ) / 2 , ( ( 2 * NSTPY + 1 ) - 1 ) / 2 };
		
		
		
		for( int t = 0 ; t < ( 2 * NSTPT + 1 ) ; t++ )
		{
			final int x = cntrVals[ 1 ];
			final int y = cntrVals[ 2 ];
			if( nodes[ t ][ x ][ y ] == null )
			{
				nodes[ t ][ x ][ y ] =  loadNeuralNode( "wvals_txt_" + t + "_" + x + "_" + y + "_.txt" , "bvals_txt_" + t + "_" + x + "_" + y + "_.txt" );
			}
		}
		
		
		
		for( int x = 0 ; x < ( 2 * NSTPX + 1 ) ; x++ )
		{
			final int t = cntrVals[ 0 ];
			final int y = cntrVals[ 2 ];
			if( nodes[ t ][ x ][ y ] == null )
			{
				nodes[ t ][ x ][ y ] =  loadNeuralNode( "wvals_txt_" + t + "_" + x + "_" + y + "_.txt" , "bvals_txt_" + t + "_" + x + "_" + y + "_.txt" );
			}
		}
		
		
		
		for( int y = 0 ; y < ( 2 * NSTPY + 1 ) ; y++ )
		{
			final int t = cntrVals[ 0 ];
			final int x = cntrVals[ 1 ];
			if( nodes[ t ][ x ][ y ] == null )
			{
				nodes[ t ][ x ][ y ] =  loadNeuralNode( "wvals_txt_" + t + "_" + x + "_" + y + "_.txt" , "bvals_txt_" + t + "_" + x + "_" + y + "_.txt" );
			}
		}
		
		
		
		/* System.out.println( node.wvals_h1[ 15 ][ 15 ] );
		System.out.println( node.wvals_h2[ 15 ][ 15 ] );
		System.out.println( node.wvals_h3[ 15 ][ 15 ] );
		System.out.println( node.wvals_h4[ 15 ][ 15 ] );
		System.out.println( node.wvals_out[ 15 ][ 0 ] );
		
		System.out.println( node.bvals_h1[ 15 ] );
		System.out.println( node.bvals_h2[ 15 ] );
		System.out.println( node.bvals_h3[ 15 ] );
		System.out.println( node.bvals_h4[ 15 ] );
		System.out.println( node.bvals_out[ 0 ] ); */
		
		
	}
	
	
	
	/**
	 * The maximum of the absolute value of the inputs.
	 */
	protected double nnAbsMax = 0.0;
	
	
	
	
	protected void evalNode( final double[] nnvals , final int t , final int x , final int y , final double[][][] out  )
	{
		
		
		if( nodes[ t ][ x ][ y ] != null )
		{
			
			System.out.print( out[ t ][ x ][ y ] + " // " );
			
			final NeuralNode node = nodes[ t ][ x ][ y ];
			
			out[ t ][ x ][ y ] = node.eval( nnvals ) * nnAbsMax;
			
			System.out.println( out[ t ][ x ][ y ] );
			
		}
		
		
	}
	
	
	
	
	
	protected void evalNode( final double[] nnvals , final double[][][] out  )
	{
		
		
		for( int t = 0 ; t < ( 2 * NSTPT + 1 ) ; t++ )
		{
			for( int x = 0 ; x < ( 2 * NSTPX + 1 ) ; x++ )
			{
				for( int y = 0 ; y < ( 2 * NSTPY + 1 ) ; y++ )
				{
					evalNode( nnvals , t , x , y , out  );
				}
			}
		}
		
		
	}
	
	
	
	
	
	
	/**
	 * Tests the ability to load text files for a 3-D TensorFlow neural-net model for slope estimation from NNFSA (Neural-Net Generator For Simple Algebra) and evaluates the neural-net for a random input.
	 * 
	 * Note: the wvals and bvals files loaded by this class are not checked-in, but are instead generated by the runExport3d_a.sh script in NNFSA.
	 * 
	 * @throws Throwable
	 */
	public void testRun3D() throws Throwable 
	{
		
		load3D();
		
		
		final Random rand = new Random( 2345 );
		
		
		
		final double[][][] out = new double[ ( 2 * NSTPT + 1 ) ][ ( 2 * NSTPX + 1 ) ][ ( 2 * NSTPY + 1 ) ];
		final double[] nnvals = new double[ ( ( 2 * NSTPT + 1 ) - 1 ) * ( 2 * NSTPX + 1 ) * ( 2 * NSTPY + 1 ) ];
		
		
		for( int t = 0 ; t < ( ( 2 * NSTPT + 1 ) - 1 ) ; t++ )
		{
			for( int x = 0 ; x < ( 2 * NSTPX + 1 ) ; x++ )
			{
				for( int y = 0 ; y < ( 2 * NSTPY + 1 ) ; y++ )
				{
					out[ t ][ x ][ y ] = rand.nextDouble();
					nnvals[ ( 2 * NSTPX + 1 ) * ( 2 * NSTPY + 1 ) * t + ( 2 * NSTPY + 1 ) * x + y ] = out[ t ][ x ][ y ];
					nnAbsMax = Math.max( nnAbsMax ,  Math.abs( nnvals[ ( 2 * NSTPX + 1 ) * ( 2 * NSTPY + 1 ) * t + ( 2 * NSTPY + 1 ) * x + y ] ) );
				}
			}
		}
		
		
		
		if( nnAbsMax < 1E-30 )
		{
			nnAbsMax = 1E-30;
		}
		
		
		
		for( int i = 0 ; i < nnvals.length ; i++ )
		{
			nnvals[ i ] = nnvals[ i ] / nnAbsMax;
		}
		
		
		
		for( int x = 0 ; x < ( 2 * NSTPX + 1 ) ; x++ )
		{
			for( int y = 0 ; y < ( 2 * NSTPY + 1 ) ; y++ )
			{
				out[ ( 2 * NSTPT + 1 ) - 1 ][ x ][ y ] = out[ ( 2 * NSTPT + 1 ) - 2 ][ x ][ y ];
			}
		}
		
		
		
		evalNode( nnvals , out  );
		
		
		
	}
	
	
	
	
	
	
	
	
	
	static final int NSTPT = 2;
	
	
	static final int NSTPX = 2;
	
	
	static final int NSTPY = 2;
	
	
	

	
	
	
	
	

}




