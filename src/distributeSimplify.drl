

//$$strtCprt
//
// Simple Algebra 
// 
// Copyright (C) 2014 Thornton Green
// 
// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with this program; if not, 
// see <http://www.gnu.org/licenses>.
// Additional permission under GNU GPL version 3 section 7
//
//
//$$endCprt

package simplealgebra.symbolic




import simplealgebra.ga.SymbolicReverseLeft;
import simplealgebra.ga.SymbolicReverseRight;
import simplealgebra.ga.SymbolicDot;
import simplealgebra.ga.SymbolicWedge;
import simplealgebra.ga.GeometricAlgebraMultivectorElemFactory;






rule "Apply Placeholder"
     when
          r0 : Reng( )
          p : SymbolicPlaceholder( elem == r0.getStrt() )
     then
          modify( p ){ setElem( r0.getEnd() ) };
end






rule "Apply Negate"
     when
          r0 : Reng( )
          p : SymbolicNegate( elem == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicNegate( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end






rule "Apply Absolute Value"
     when
          r0 : Reng( )
          p : SymbolicAbsoluteValue( elem == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicAbsoluteValue( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end







rule "Apply Invert Left"
     when
          r0 : Reng( )
          p : SymbolicInvertLeft( elem == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicInvertLeft( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end







rule "Apply Invert Right"
     when
          r0 : Reng( )
          p : SymbolicInvertRight( elem == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicInvertRight( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end








rule "Apply Reverse Left"
     when
          r0 : Reng( )
          p : SymbolicReverseLeft( elemA == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicReverseLeft( r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end







rule "Apply Reverse Right"
     when
          r0 : Reng( )
          p : SymbolicReverseRight( elemA == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicReverseRight( r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end








rule "Apply Divide By"
     when
          r0 : Reng( )
          p : SymbolicDivideBy( elem == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicDivideBy( r0.getEnd() , p.getFac().getFac() , p.getIval() , ds ) ) );
end








rule "Apply Mutable"
     when
          r0 : Reng( )
          p : SymbolicMutable( elemA == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicMutable( r0.getEnd() , p.getElemB() , p.getFac().getFac() , ds ) ) );
end








rule "Apply AddA"
     when
          r0 : Reng( )
          p : SymbolicAdd( elemA == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicAdd( r0.getEnd() , p.getElemB() , p.getFac().getFac() , ds ) ) );
end





rule "Apply AddB"
     when
          r0 : Reng( )
          p : SymbolicAdd( elemB == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicAdd( p.getElemA() , r0.getEnd() , p.getFac().getFac() , ds ) ) );
end





rule "Apply MultA"
     when
          r0 : Reng( )
          p : SymbolicMult( elemA == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicMult( r0.getEnd() , p.getElemB() , p.getFac().getFac() , ds ) ) );
end





rule "Apply MultB"
     when
          r0 : Reng( )
          p : SymbolicMult( elemB == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicMult( p.getElemA() , r0.getEnd() , p.getFac().getFac() , ds ) ) );
end






rule "Apply DotA"
     when
          r0 : Reng( )
          p : SymbolicDot( elemA == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicDot( r0.getEnd() , p.getElemB() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end





rule "Apply DotB"
     when
          r0 : Reng( )
          p : SymbolicDot( elemB == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicDot( p.getElemA() , r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end








rule "Apply WedgeA"
     when
          r0 : Reng( )
          p : SymbolicWedge( elemA == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicWedge( r0.getEnd() , p.getElemB() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end





rule "Apply WedgeB"
     when
          r0 : Reng( )
          p : SymbolicWedge( elemB == r0.getStrt() )
          ds : DroolsSession()
          not( Reng( strt == p ) )
     then
          insert( new Reng( p , new SymbolicWedge( p.getElemA() , r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end






rule "Double Negate"
     when
          e0 : SymbolicElem( )
          n0 : SymbolicNegate( elem == e0 )
          n1 : SymbolicNegate( elem == n0 )
          not( Reng( strt == n1 ) )
     then
          insert( new Reng( n1 , e0 ) );
end






rule "Double Absolute Value"
     when
          n0 : SymbolicAbsoluteValue( )
          n1 : SymbolicAbsoluteValue( elem == n0 )
          not( Reng( strt == n1 ) )
     then
          insert( new Reng( n1 , n0 ) );
end







rule "Double Invert Left NonCommute"
     when
          e0 : SymbolicElem( )
          n0 : SymbolicInvertLeft( elem == e0 )
          n1 : SymbolicInvertRight( elem == n0 )
          not( Reng( strt == n1 ) )
     then
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Right NonCommute"
     when
          e0 : SymbolicElem( )
          n0 : SymbolicInvertRight( elem == e0 )
          n1 : SymbolicInvertLeft( elem == n0 )
          not( Reng( strt == n1 ) )
     then
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Left Commute"
     when
          e0 : SymbolicElem( )
          n0 : SymbolicInvertLeft( elem == e0 )
          n1 : SymbolicInvertLeft( elem == n0 )
          eval( e0.getFac().isNestedMultCommutative() )
          not( Reng( strt == n1 ) )
     then
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Right Commute"
     when
          e0 : SymbolicElem( )
          n0 : SymbolicInvertRight( elem == e0 )
          n1 : SymbolicInvertRight( elem == n0 )
          eval( e0.getFac().isNestedMultCommutative() )
          not( Reng( strt == n1 ) )
     then
          insert( new Reng( n1 , e0 ) );
end





rule "Negate Zero"
      when
          ez : SymbolicZero( )
          n1 : SymbolicNegate( elem == ez )
          not( Reng( strt == n1 ) )
      then
          insert( new Reng( n1 , ez ) );
end



rule "Add Zero A"
      when
          ez : SymbolicZero( )
          nez : SymbolicElem( )
          add1 : SymbolicAdd( elemA == ez , elemB == nez )
          not( Reng( strt == add1 ) )
      then
          // System.out.println( "Add Zero A" );
          insert( new Reng( add1 , nez ) );
end




rule "Add Zero B"
      when
          ez : SymbolicZero( )
          nez : SymbolicElem( )
          add1 : SymbolicAdd( elemA == nez , elemB == ez )
          not( Reng( strt == add1 ) )
      then
          // System.out.println( "Add Zero B" );
          insert( new Reng( add1 , nez ) );
end





rule "Mult Ident A"
      when
          ez : SymbolicIdentity( )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == ez , elemB == nez )
          not( Reng( strt == mult1 ) )
      then
          insert( new Reng( mult1 , nez ) );
end




rule "Mult Ident B"
      when
          ez : SymbolicIdentity( )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == nez , elemB == ez )
          not( Reng( strt == mult1 ) )
      then
          insert( new Reng( mult1 , nez ) );
end




rule "Mult Zero A"
      when
          ez : SymbolicZero( )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == ez , elemB == nez )
          not( Reng( strt == mult1 ) )
      then
          insert( new Reng( mult1 , ez ) );
end




rule "Mult Zero B"
      when
          ez : SymbolicZero( )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == nez , elemB == ez )
          not( Reng( strt == mult1 ) )
      then
          insert( new Reng( mult1 , ez ) );
end





rule "Mult Over Negate A"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          na : SymbolicNegate( elem == a )
          mult1 : SymbolicMult( elemA == na , elemB == b )
          ds : DroolsSession()
          not( Reng( strt == mult1 ) )
      then
          insert( new Reng( mult1 , new SymbolicNegate( new SymbolicMult( a , b , mult1.getFac().getFac() , ds ) , na.getFac().getFac() , ds ) ) );
end




rule "Mult Over Negate B"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          nb : SymbolicNegate( elem == b )
          mult1 : SymbolicMult( elemA == a , elemB == nb )
          ds : DroolsSession()
          not( Reng( strt == mult1 ) )
      then
          insert( new Reng( mult1 , new SymbolicNegate( new SymbolicMult( a , b , mult1.getFac().getFac() , ds ) , nb.getFac().getFac() , ds ) ) );
end






rule "Mult Over DivideBy A"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          na : SymbolicDivideBy( elem == a )
          mult1 : SymbolicMult( elemA == na , elemB == b )
          ds : DroolsSession()
          not( Reng( strt == mult1 ) )
      then
          insert( new Reng( mult1 , new SymbolicDivideBy( new SymbolicMult( a , b , mult1.getFac().getFac() , ds ) , na.getFac().getFac() , na.getIval() , ds ) ) );
end




rule "Mult Over DivideBy B"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          nb : SymbolicDivideBy( elem == b )
          mult1 : SymbolicMult( elemA == a , elemB == nb )
          ds : DroolsSession()
          not( Reng( strt == mult1 ) )
      then
          insert( new Reng( mult1 , new SymbolicDivideBy( new SymbolicMult( a , b , mult1.getFac().getFac() , ds ) , nb.getFac().getFac() , nb.getIval() , ds ) ) );
end






rule "Negate Over Add"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          c : SymbolicAdd( elemA == a , elemB == b )
          d : SymbolicNegate( elem == c )
          ds : DroolsSession()
          not( Reng( strt == d ) )
      then
          insert( new Reng( d , new SymbolicAdd( new SymbolicNegate( a , d.getFac().getFac() , ds ) , new SymbolicNegate( b , d.getFac().getFac() , ds ) , c.getFac().getFac() , ds ) ) );
end





rule "DivideBy Over Add"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          c : SymbolicAdd( elemA == a , elemB == b )
          d : SymbolicDivideBy( elem == c )
          ds : DroolsSession()
          not( Reng( strt == d ) )
      then
          insert( new Reng( d , new SymbolicAdd( new SymbolicDivideBy( a , d.getFac().getFac() , d.getIval() , ds ) , new SymbolicDivideBy( b , d.getFac().getFac() , d.getIval() , ds ) , c.getFac().getFac() , ds ) ) );
end





rule "DivideBy Over Negate"
      when
          a : SymbolicElem( )
          b : SymbolicNegate( elem == a )
          c : SymbolicDivideBy( elem == b )
          ds : DroolsSession()
          not( Reng( strt == c ) )
      then
          insert( new Reng( c , new SymbolicNegate( new SymbolicDivideBy( a , c.getFac().getFac() , c.getIval() , ds ) , b.getFac().getFac() , ds ) ) );
end






rule "Init Add Root"
      when
          elA : SymbolicAdd( )
      then
          // System.out.println( "Init Add Root " + elA );
          insert( new AddRoot( elA , elA ) );
end





rule "Add RootA"
      when
          el0 : SymbolicAdd()
          elA : AddRoot( elemB == el0 )
          elB : SymbolicAdd( elemA == el0 )
      then
          // System.out.println( "Add Root A " + elA.getElemA() + " " + elB );
          insert( new AddRoot( elA.getElemA() , elB ) );
end





rule "Add RootB"
      when
          el0 : SymbolicAdd()
          elA : AddRoot( elemB == el0 )
          elB : SymbolicAdd( elemB == el0 )
      then
          // System.out.println( "Add Root B " + elA.getElemA() + " " + elB );
          insert( new AddRoot( elA.getElemA() , elB ) );
end




rule "El Plus Negative ElA"
      when
          elA : SymbolicElem( eval( !( elA instanceof SymbolicAdd ) ) )
          elB : SymbolicElem( eval( !( elB instanceof SymbolicAdd ) ) )
          addA : SymbolicAdd( elemA == elA )
          addB : SymbolicAdd( elemA == elB )
          r1: AddRoot( elemA == addA )
          AddRoot( elemA == addB , elemB == r1.getElemB() )
          eval( elA.extSymbolicEquals( new SymbolicNegate( elB , elB.getFac().getFac() ) ) )
          eval( elA != elB )
          ds: DroolsSession()
          not( Reng( strt == r1.getElemB() ) )
      then
          // System.out.println( "ElA " + addA + " " + addB );
          insert( new Reng( r1.getElemB() , r1.getElemB().handleAddSimplify( elA , elB , ds ) ) );
end





rule "El Plus Negative ElB"
      when
          elA : SymbolicElem( eval( !( elA instanceof SymbolicAdd ) ) )
          elB : SymbolicElem( eval( !( elB instanceof SymbolicAdd ) ) )
          addA : SymbolicAdd( elemB == elA )
          addB : SymbolicAdd( elemA == elB )
          r1: AddRoot( elemA == addA )
          AddRoot( elemA == addB , elemB == r1.getElemB() )
          eval( elA.extSymbolicEquals( new SymbolicNegate( elB , elB.getFac().getFac() ) ) )
          eval( elA != elB )
          ds:DroolsSession()
          not( Reng( strt == r1.getElemB() ) )
      then
          // System.out.println( "ElB " + addA + " " + addB );
          insert( new Reng( r1.getElemB() , r1.getElemB().handleAddSimplify( elA , elB , ds ) ) );
end






rule "El Plus Negative ElD"
      when
          elA : SymbolicElem( eval( !( elA instanceof SymbolicAdd ) ) )
          elB : SymbolicElem( eval( !( elB instanceof SymbolicAdd ) ) )
          addA : SymbolicAdd( elemB == elA )
          addB : SymbolicAdd( elemB == elB )
          r1: AddRoot( elemA == addA )
          AddRoot( elemA == addB , elemB == r1.getElemB() )
          eval( elA.extSymbolicEquals( new SymbolicNegate( elB , elB.getFac().getFac() ) ) )
          eval( elA != elB )
          ds:DroolsSession()
          not( Reng( strt == r1.getElemB() ) )
      then
          // System.out.println( "ElB " + addA + " " + addB );
          insert( new Reng( r1.getElemB() , r1.getElemB().handleAddSimplify( elA , elB , ds ) ) );
end







rule "Mult RootA"
      when
          el0 : SymbolicMult()
          eval( !( el0.getElemA() instanceof SymbolicMult ) )
          eval( !( el0.getElemB() instanceof SymbolicMult ) )
      then
          insert( new MultFirst( el0 , el0.getElemA() ) );
          insert( new MultLast( el0 , el0.getElemB() ) );
          insert( new MultNext( el0 , el0.getElemA() , el0.getElemB() ) );
end







rule "Mult RootB"
      when
          el0 : SymbolicMult()
          eval( !( el0.getElemA() instanceof SymbolicMult ) )
          bf: MultFirst( root == el0.getElemB() )
          bl: MultLast( root == el0.getElemB() )
      then
          insert( new MultFirst( el0 , el0.getElemA() ) );
          insert( new MultLast( el0 , bl.getLast() ) );
          insert( new MultNext( el0 , el0.getElemA() , bf.getFirst() ) );
end








rule "Mult RootC"
      when
          el0 : SymbolicMult()
          eval( !( el0.getElemB() instanceof SymbolicMult ) )
          bf: MultFirst( root == el0.getElemA() )
          bl: MultLast( root == el0.getElemA() )
      then
          insert( new MultFirst( el0 , bf.getFirst() ) );
          insert( new MultLast( el0 , el0.getElemB() ) );
          insert( new MultNext( el0 , bl.getLast() , el0.getElemB() ) );
end







rule "Mult RootD"
      when
          el0 : SymbolicMult()
          bf0: MultFirst( root == el0.getElemA() )
          bl0: MultLast( root == el0.getElemA() )
          bf1: MultFirst( root == el0.getElemB() )
          bl1: MultLast( root == el0.getElemB() )
      then
          insert( new MultFirst( el0 , bf0.getFirst() ) );
          insert( new MultLast( el0 , bl1.getLast() ) );
          insert( new MultNext( el0 , bl0.getLast() , bf1.getFirst() ) );
end










rule "Mult RootX0"
      when
          el0 : SymbolicMult()
          mn: MultNext( root == el0.getElemB() )
      then
          insert( new MultNext( el0 , mn.getFirst() , mn.getNext() ) );
end






rule "Mult RootX1"
      when
          el0 : SymbolicMult()
          mn: MultNext( root == el0.getElemA() )
      then
          insert( new MultNext( el0 , mn.getFirst() , mn.getNext() ) );
end







rule "Inv El Mult El"
      when
          elA : SymbolicElem( eval( !( elA instanceof SymbolicMult ) ) )
          elB : SymbolicElem( eval( !( elB instanceof SymbolicMult ) ) )
          mn: MultNext( first == elA , next == elB )
          eval( elB.extSymbolicEquals( new SymbolicInvertRight( elA , elA.getFac().getFac() ) ) )
          eval( elA != elB )
          ds: DroolsSession()
          not( Reng( strt == mn.getRoot() ) )
      then
          insert( new Reng( mn.getRoot() , mn.getRoot().handleMultSimplify( elA , elB , ds ) ) );
end






rule "El Mult Inv El"
      when
          elA : SymbolicElem( eval( !( elA instanceof SymbolicMult ) ) )
          elB : SymbolicElem( eval( !( elB instanceof SymbolicMult ) ) )
          mn: MultNext( first == elA , next == elB )
          eval( elA.extSymbolicEquals( new SymbolicInvertLeft( elB , elB.getFac().getFac() ) ) )
          eval( elA != elB )
          ds: DroolsSession()
          not( Reng( strt == mn.getRoot() ) )
      then
          insert( new Reng( mn.getRoot() , mn.getRoot().handleMultSimplify( elA , elB , ds ) ) );
end












