

//$$strtCprt
//
// Simple Algebra 
// 
// Copyright (C) 2014 Thornton Green
// 
// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with this program; if not, 
// see <http://www.gnu.org/licenses>.
// Additional permission under GNU GPL version 3 section 7
//
//
//$$endCprt

package simplealgebra.symbolic




import simplealgebra.ddx.PartialDerivativeOp;
import simplealgebra.ga.SymbolicReverseLeft;
import simplealgebra.ga.SymbolicReverseRight;
import simplealgebra.ga.SymbolicDot;
import simplealgebra.ga.SymbolicWedge;
import simplealgebra.ga.GeometricAlgebraMultivectorElemFactory;






rule "Apply Placeholder"
     when
          r0 : Reng( )
          p : SymbolicPlaceholder( elem == r0.getStrt() )
     then
          // System.out.println( "Apply Placeholder" );
          modify( p ){ setElem( r0.getEnd() ) };
end






rule "Apply Negate"
     when
          r0 : Reng( )
          p : SymbolicNegate( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Negate" );
          insert( new Reng( p , r0.getEnd().negate().insSym( ds ) ) );
end






rule "Apply Absolute Value"
     when
          r0 : Reng( )
          p : SymbolicAbsoluteValue( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Absolute Value" );
          insert( new Reng( p , new SymbolicAbsoluteValue( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end







rule "Apply Invert Left"
     when
          r0 : Reng( )
          p : SymbolicInvertLeft( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Invert Left" );
          insert( new Reng( p , new SymbolicInvertLeft( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end







rule "Apply Invert Right"
     when
          r0 : Reng( )
          p : SymbolicInvertRight( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Invert Right" );
          insert( new Reng( p , new SymbolicInvertRight( r0.getEnd() , p.getFac().getFac() , ds ) ) );
end








rule "Apply Reverse Left"
     when
          r0 : Reng( )
          p : SymbolicReverseLeft( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Reverse Left" );
          insert( new Reng( p , new SymbolicReverseLeft( r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end







rule "Apply Reverse Right"
     when
          r0 : Reng( )
          p : SymbolicReverseRight( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Reverse Right" );
          insert( new Reng( p , new SymbolicReverseRight( r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end








rule "Apply Divide By"
     when
          r0 : Reng( )
          p : SymbolicDivideBy( elem == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Divide By" );
          insert( new Reng( p , new SymbolicDivideBy( r0.getEnd() , p.getFac().getFac() , p.getIval() , ds ) ) );
end








rule "Apply Mutable"
     when
          r0 : Reng( )
          p : SymbolicMutable( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply Mutable" );
          insert( new Reng( p , new SymbolicMutable( r0.getEnd() , p.getElemB() , p.getFac().getFac() , ds ) ) );
end








rule "Apply AddA"
     when
          r0 : Reng( )
          p : SymbolicAdd( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply AddA" );
          insert( new Reng( p , r0.getEnd().add( p.getElemB() ).insSym( ds ) ) );
end





rule "Apply AddB"
     when
          r0 : Reng( )
          p : SymbolicAdd( elemB == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply AddB" );
          insert( new Reng( p , p.getElemA().add( r0.getEnd() ).insSym( ds ) ) );
end





rule "Apply MultA"
     when
          r0 : Reng( )
          p : SymbolicMult( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply MultA" );
          insert( new Reng( p , r0.getEnd().mult( p.getElemB() ).insSym( ds ) ) );
end





rule "Apply MultB"
     when
          r0 : Reng( )
          p : SymbolicMult( elemB == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply MultB" );
          insert( new Reng( p , p.getElemA().mult( r0.getEnd() ).insSym( ds ) ) );
end






rule "Apply DotA"
     when
          r0 : Reng( )
          p : SymbolicDot( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply DotA" );
          insert( new Reng( p , new SymbolicDot( r0.getEnd() , p.getElemB() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end





rule "Apply DotB"
     when
          r0 : Reng( )
          p : SymbolicDot( elemB == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply DotB" );
          insert( new Reng( p , new SymbolicDot( p.getElemA() , r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end








rule "Apply WedgeA"
     when
          r0 : Reng( )
          p : SymbolicWedge( elemA == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply WedgeA" );
          insert( new Reng( p , new SymbolicWedge( r0.getEnd() , p.getElemB() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end





rule "Apply WedgeB"
     when
          r0 : Reng( )
          p : SymbolicWedge( elemB == r0.getStrt() )
          not( Reng( strt == p ) )
          ds : DroolsSession()
     then
          // System.out.println( "Apply WedgeB" );
          insert( new Reng( p , new SymbolicWedge( p.getElemA() , r0.getEnd() , (GeometricAlgebraMultivectorElemFactory)( p.getFac().getFac() ) , ds ) ) );
end






// This simplification has a parallel implementation in SymbolicZero.negate()
rule "Double Negate"
     when
          n0 : SymbolicNegate( )
          n1 : SymbolicNegate( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
     then
          // System.out.println( "Double Negate" );
          insert( new Reng( n1 , e0 ) );
end






// This simplification has a parallel implementation in SymbolicDivideBy.divideBy()
rule "Double DivideBy"
     when
          n0 : SymbolicDivideBy( )
          n1 : SymbolicDivideBy( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
          ds : DroolsSession()
     then
          // System.out.println( "Double DivideBy" );
          insert( new Reng( n1 , new SymbolicDivideBy( e0 , n0.getFac() , n0.getIval().multiply( n1.getIval() ) , ds ) ) );
end






rule "Double Absolute Value"
     when
          n0 : SymbolicAbsoluteValue( )
          n1 : SymbolicAbsoluteValue( elem == n0 )
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
     then
          // System.out.println( "Double Absolute Value" );
          insert( new Reng( n1 , n0 ) );
end







rule "Double Invert Left NonCommute"
     when
          n0 : SymbolicInvertLeft( )
          n1 : SymbolicInvertRight( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
     then
          // System.out.println( "Double Invert Left NonCommute" );
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Right NonCommute"
     when
          n0 : SymbolicInvertRight( )
          n1 : SymbolicInvertLeft( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
     then
          // System.out.println( "Double Invert Right NonCommute" );
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Left Commute"
     when
          n0 : SymbolicInvertLeft( )
          n1 : SymbolicInvertLeft( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
          eval( e0.getFac().isNestedMultCommutative() )
     then
          // System.out.println( "Double Invert Left Commute" );
          insert( new Reng( n1 , e0 ) );
end






rule "Double Invert Right Commute"
     when
          n0 : SymbolicInvertRight( )
          n1 : SymbolicInvertRight( elem == n0 )
          e0 : SymbolicElem() from n0.getElem()
          not( Reng( strt == n1 ) )
          not( Reng( strt == n0 ) )
          not( Reng( strt == e0 ) )
          eval( e0.getFac().isNestedMultCommutative() )
     then
          // System.out.println( "Double Invert Right Commute" );
          insert( new Reng( n1 , e0 ) );
end





// This simplification has a parallel implementation in SymbolicZero.negate()
rule "Negate Zero"
      when
          ez : SymbolicZero( )
          n1 : SymbolicNegate( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Negate Zero" );
          insert( new Reng( n1 , ez ) );
end




// This simplification has a parallel implementation in SymbolicZero.add()
rule "Add Zero A"
      when
          ez : SymbolicZero( )
          add1 : SymbolicAdd( elemA == ez )
          elB : SymbolicElem() from add1.getElemB()
          not( Reng( strt == add1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Add Zero A" );
          insert( new Reng( add1 , elB ) );
end




// This simplification has a parallel implementation in SymbolicElem.add()
rule "Add Zero B"
      when
          ez : SymbolicZero( )
          add1 : SymbolicAdd( elemB == ez )
          elA : SymbolicElem() from add1.getElemA()
          not( Reng( strt == add1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Add Zero B" );
          insert( new Reng( add1 , elA ) );
end





// This simplification has a parallel implementation in SymbolicIdentity.mult()
rule "Mult Ident A"
      when
          ez : SymbolicIdentity( )
          mult1 : SymbolicMult( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Ident A" );
          insert( new Reng( mult1 , elB ) );
end




rule "Mult Ident B"
      when
          ez : SymbolicIdentity( )
          mult1 : SymbolicMult( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
          eval( !( elA.exposesDerivatives() ) )
      then
          // System.out.println( "Mult Ident B" );
          insert( new Reng( mult1 , elA ) );
end





// This simplification has a parallel implementation in SymbolicZero.mult()
rule "Mult Zero A"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicMult( elemA == ez )
          elB : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elB ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Zero A" );
          insert( new Reng( mult1 , ez ) );
end





// This simplification has a parallel implementation in SymbolicElem.mult()
rule "Mult Zero B"
      when
          ez : SymbolicZero( )
          mult1 : SymbolicMult( elemB == ez )
          elA : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Mult Zero B" );
          insert( new Reng( mult1 , ez ) );
end





rule "Mult Over Negate A"
      when
          na : SymbolicNegate( )
          mult1 : SymbolicMult( elemA == na )
          a : SymbolicElem() from na.getElem()
          b : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == na ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over Negate A" );
          insert( new Reng( mult1 , a.mult( b ).insSym( ds ).negate().insSym( ds ) ) );
end




rule "Mult Over Negate B"
      when
          nb : SymbolicNegate( )
          mult1 : SymbolicMult( elemB == nb )
          a : SymbolicElem() from mult1.getElemA()
          b : SymbolicElem() from nb.getElem()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nb ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over Negate B" );
          insert( new Reng( mult1 , a.mult( b ).insSym( ds ).negate().insSym( ds ) ) );
end






rule "Mult Over DivideBy A"
      when
          na : SymbolicDivideBy( )
          mult1 : SymbolicMult( elemA == na )
          a : SymbolicElem() from na.getElem()
          b : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == na ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over DivideBy A" );
          insert( new Reng( mult1 , new SymbolicDivideBy( a.mult( b ).insSym( ds ) , na.getFac().getFac() , na.getIval() , ds ) ) );
end




rule "Mult Over DivideBy B"
      when
          nb : SymbolicDivideBy( )
          mult1 : SymbolicMult( elemB == nb )
          a : SymbolicElem() from mult1.getElemA()
          b : SymbolicElem() from nb.getElem()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nb ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds : DroolsSession()
      then
          // System.out.println( "Mult Over DivideBy B" );
          insert( new Reng( mult1 , new SymbolicDivideBy( a.mult( b ).insSym( ds ) , nb.getFac().getFac() , nb.getIval() , ds ) ) );
end






rule "Negate Over Add"
      when
          c : SymbolicAdd( )
          d : SymbolicNegate( elem == c )
          a : SymbolicElem() from c.getElemA()
          b : SymbolicElem() from c.getElemB()
          not( Reng( strt == d ) )
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "Negate Over Add" );
          insert( new Reng( d , a.negate().insSym( ds ).add( b.negate().insSym( ds ) ).insSym( ds ) ) );
end





rule "DivideBy Over Add"
      when
          c : SymbolicAdd( )
          d : SymbolicDivideBy( elem == c )
          a : SymbolicElem() from c.getElemA()
          b : SymbolicElem() from c.getElemB()
          not( Reng( strt == d ) )
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "DivideBy Over Add" );
          insert( new Reng( d , new SymbolicAdd( new SymbolicDivideBy( a , d.getFac().getFac() , d.getIval() , ds ) , new SymbolicDivideBy( b , d.getFac().getFac() , d.getIval() , ds ) , c.getFac().getFac() , ds ) ) );
end





rule "DivideBy Over Negate"
      when
          b : SymbolicNegate( )
          c : SymbolicDivideBy( elem == b )
          a : SymbolicElem() from b.getElem()
          not( Reng( strt == c ) )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
      then
          // System.out.println( "DivideBy Over Negate" );
          insert( new Reng( c , new SymbolicNegate( new SymbolicDivideBy( a , c.getFac().getFac() , c.getIval() , ds ) , b.getFac().getFac() , ds ) ) );
end






rule "Init Add Root"
      when
          elA : SymbolicAdd( )
          not( Reng( strt == elA ) )
      then
          // System.out.println( "Init Add Root " + elA );
          insert( new AddRoot( elA , elA ) );
end





rule "Add RootA"
      when
          el0 : SymbolicAdd()
          elA : AddRoot( elemB == el0 )
          elB : SymbolicAdd( elemA == el0 )
          not( Reng( strt == elB ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == el0 ) )
      then
          // System.out.println( "Add Root A " + elA.getElemA() + " " + elB );
          insert( new AddRoot( elA.getElemA() , elB ) );
end





rule "Add RootB"
      when
          el0 : SymbolicAdd()
          elA : AddRoot( elemB == el0 )
          elB : SymbolicAdd( elemB == el0 )
          not( Reng( strt == elB ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == el0 ) )
      then
          // System.out.println( "Add Root B " + elA.getElemA() + " " + elB );
          insert( new AddRoot( elA.getElemA() , elB ) );
end




rule "El Plus Negative ElA"
      when
          r1: AddRoot( )
          r1b: SymbolicAdd() from r1.getElemB()
          r2: AddRoot( elemB == r1b )
          addA : SymbolicAdd( ) from r1.getElemA()
          addB : SymbolicAdd( ) from r2.getElemA()
          elA : SymbolicElem() from addA.getElemA()
          elB : SymbolicElem() from addB.getElemA()
          eval( !( elA instanceof SymbolicAdd ) )
          eval( !( elB instanceof SymbolicAdd ) )
          eval( elA.extSymbolicEquals( elB.negate() ) )
          eval( elA != elB )
          ds: DroolsSession()
          not( Reng( strt == r1b ) )
          not( Reng( strt == addA ) )
          not( Reng( strt == addB ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == elB ) )
      then
          // System.out.println( "ElA " + addA + " " + addB );
          insert( new Reng( r1b , r1b.handleAddSimplify( elA , elB , ds ) ) );
end





rule "El Plus Negative ElB"
      when
          r1: AddRoot( )
          r1b: SymbolicAdd() from r1.getElemB()
          r2: AddRoot( elemB == r1b )
          addA : SymbolicAdd( ) from r1.getElemA()
          addB : SymbolicAdd( ) from r2.getElemA()
          elA : SymbolicElem() from addA.getElemB()
          elB : SymbolicElem() from addB.getElemA()
          eval( !( elA instanceof SymbolicAdd ) )
          eval( !( elB instanceof SymbolicAdd ) )
          eval( elA.extSymbolicEquals( elB.negate() ) )
          eval( elA != elB )
          ds:DroolsSession()
          not( Reng( strt == r1b ) )
          not( Reng( strt == addA ) )
          not( Reng( strt == addB ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == elB ) )
      then
          // System.out.println( "ElB " + addA + " " + addB );
          insert( new Reng( r1b , r1b.handleAddSimplify( elA , elB , ds ) ) );
end






rule "El Plus Negative ElD"
      when
          r1: AddRoot( )
          r1b: SymbolicAdd() from r1.getElemB()
          r2: AddRoot( elemB == r1b )
          addA : SymbolicAdd( ) from r1.getElemA()
          addB : SymbolicAdd( ) from r2.getElemA()
          elA : SymbolicElem() from addA.getElemB()
          elB : SymbolicElem() from addB.getElemB()
          eval( !( elA instanceof SymbolicAdd ) )
          eval( !( elB instanceof SymbolicAdd ) )
          eval( elA.extSymbolicEquals( elB.negate() ) )
          eval( elA != elB )
          ds:DroolsSession()
          not( Reng( strt == r1b ) )
          not( Reng( strt == addA ) )
          not( Reng( strt == addB ) )
          not( Reng( strt == elA ) )
          not( Reng( strt == elB ) )
      then
          // System.out.println( "ElB " + addA + " " + addB );
          insert( new Reng( r1b , r1b.handleAddSimplify( elA , elB , ds ) ) );
end







rule "Mult RootA"
      when
          el0 : SymbolicMult()
          eval( el0.getFac().isMultAssociative() )
          a : SymbolicElem() from el0.getElemA()
          b : SymbolicElem() from el0.getElemB()
          eval( !( a instanceof SymbolicMult ) )
          eval( !( b instanceof SymbolicMult ) )
          not( Reng( strt == el0 ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
      then
          // System.out.println( "Mult RootA" );
          insert( new MultFirst( el0 , a ) );
          insert( new MultLast( el0 , b ) );
          insert( new MultNext( el0 , a , b ) );
end







rule "Mult RootB"
      when
          el0 : SymbolicMult()
          eval( el0.getFac().isMultAssociative() )
          a : SymbolicElem() from el0.getElemA()
          b : SymbolicElem() from el0.getElemB()
          eval( !( a instanceof SymbolicMult ) )
          bf: MultFirst( root == b )
          bl: MultLast( root == b )
          not( Reng( strt == el0 ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
      then
          // System.out.println( "Mult RootB" );
          insert( new MultFirst( el0 , a ) );
          insert( new MultLast( el0 , bl.getLast() ) );
          insert( new MultNext( el0 , a , bf.getFirst() ) );
end








rule "Mult RootC"
      when
          el0 : SymbolicMult()
          eval( el0.getFac().isMultAssociative() )
          a : SymbolicElem() from el0.getElemA()
          b : SymbolicElem() from el0.getElemB()
          eval( !( b instanceof SymbolicMult ) )
          bf: MultFirst( root == a )
          bl: MultLast( root == a )
          not( Reng( strt == el0 ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
      then
          // System.out.println( "Mult RootC" );
          insert( new MultFirst( el0 , bf.getFirst() ) );
          insert( new MultLast( el0 , b ) );
          insert( new MultNext( el0 , bl.getLast() , b ) );
end







rule "Mult RootD"
      when
          el0 : SymbolicMult()
          eval( el0.getFac().isMultAssociative() )
          a : SymbolicElem() from el0.getElemA()
          b : SymbolicElem() from el0.getElemB()
          bf0: MultFirst( root == a )
          bl0: MultLast( root == a )
          bf1: MultFirst( root == b )
          bl1: MultLast( root == b )
          not( Reng( strt == el0 ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
      then
          // System.out.println( "Mult RootD" );
          insert( new MultFirst( el0 , bf0.getFirst() ) );
          insert( new MultLast( el0 , bl1.getLast() ) );
          insert( new MultNext( el0 , bl0.getLast() , bf1.getFirst() ) );
end










rule "Mult RootX0"
      when
          el0 : SymbolicMult()
          eval( el0.getFac().isMultAssociative() )
          mn: MultNext( root == el0.getElemB() )
          not( Reng( strt == el0 ) )
      then
          // System.out.println( "Mult RootX0" );
          insert( new MultNext( el0 , mn.getFirst() , mn.getNext() ) );
end






rule "Mult RootX1"
      when
          el0 : SymbolicMult()
          eval( el0.getFac().isMultAssociative() )
          mn: MultNext( root == el0.getElemA() )
          not( Reng( strt == el0 ) )
      then
          // System.out.println( "Mult RootX1" );
          insert( new MultNext( el0 , mn.getFirst() , mn.getNext() ) );
end







rule "Inv El Mult El Associative"
      when
          mn: MultNext( )
          a : SymbolicElem() from mn.getFirst()
          b : SymbolicElem() from mn.getNext()
          rt : SymbolicMult() from mn.getRoot()
          eval( !( a instanceof SymbolicMult ) )
          eval( !( b instanceof SymbolicMult ) )
          eval( a.getFac().isMultAssociative() )
          eval( !( a instanceof SymbolicIdentity ) )
          eval( !( b instanceof SymbolicIdentity ) )
          eval( b.extSymbolicEquals( a.invertRight() ) )
          eval( a != b )
          ds: DroolsSession()
          not( Reng( strt == rt ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
      then
          // System.out.println( "Inv El Mult El Associative" );
          insert( new Reng( rt , rt.handleMultSimplify( a , b , ds ) ) );
end






rule "El Mult Inv El Associative"
      when
          mn: MultNext( )
          a : SymbolicElem() from mn.getFirst()
          b : SymbolicElem() from mn.getNext()
          rt : SymbolicMult() from mn.getRoot()
          eval( !( a instanceof SymbolicMult ) )
          eval( !( b instanceof SymbolicMult ) )
          eval( a.getFac().isMultAssociative() )
          eval( !( a instanceof SymbolicIdentity ) )
          eval( !( b instanceof SymbolicIdentity ) )
          eval( a.extSymbolicEquals( b.invertLeft() ) )
          eval( a != b )
          ds: DroolsSession()
          not( Reng( strt == rt ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
      then
          // System.out.println( "El Mult Inv El Associative" );
          insert( new Reng( rt , rt.handleMultSimplify( a , b , ds ) ) );
end








rule "Inv El Mult El Non-Associative"
      when
          mn: SymbolicMult( )
          a : SymbolicElem() from mn.getElemA()
          b : SymbolicElem() from mn.getElemB()
          eval( !( a instanceof SymbolicMult ) )
          eval( !( b instanceof SymbolicMult ) )
          eval( !( mn.getFac().isMultAssociative() ) )
          eval( !( a instanceof SymbolicIdentity ) )
          eval( !( b instanceof SymbolicIdentity ) )
          eval( b.extSymbolicEquals( a.invertRight() ) )
          eval( a != b )
          ds: DroolsSession()
          not( Reng( strt == mn ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
      then
          // System.out.println( "Inv El Mult El Non-Associative" );
          insert( new Reng( mn , new SymbolicIdentity( mn.getFac().getFac() , ds ) ) );
end








rule "El Mult Inv El Non-Associative"
      when
          mn: SymbolicMult( )
          a : SymbolicElem() from mn.getElemA()
          b : SymbolicElem() from mn.getElemB()
          eval( !( a instanceof SymbolicMult ) )
          eval( !( b instanceof SymbolicMult ) )
          eval( !( mn.getFac().isMultAssociative() ) )
          eval( !( a instanceof SymbolicIdentity ) )
          eval( !( b instanceof SymbolicIdentity ) )
          eval( a.extSymbolicEquals( b.invertLeft() ) )
          eval( a != b )
          ds: DroolsSession()
          not( Reng( strt == mn ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
      then
          // System.out.println( "El Mult Inv El Non-Associative" );
          insert( new Reng( mn , new SymbolicIdentity( mn.getFac().getFac() , ds ) ) );
end








rule "Distribute InvertLeft Over Mult"
      when
          elm : SymbolicMult()
          el0 : SymbolicInvertLeft( elem == elm )
          a : SymbolicElem() from elm.getElemA()
          b : SymbolicElem() from elm.getElemB()
          not( Reng( strt == el0 ) )
          not( Reng( strt == elm ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds: DroolsSession()
      then
         // System.out.println( "Distribute InvertLeft Over Mult" );
         insert( new Reng( el0 , new SymbolicMult( new SymbolicInvertLeft( b , el0.getFac().getFac() , ds ) , new SymbolicInvertLeft( a , el0.getFac().getFac() , ds ) , elm.getFac().getFac() , ds ) ) );
end










rule "Distribute InvertRight Over Mult"
      when
          elm : SymbolicMult()
          el0 : SymbolicInvertRight( elem == elm )
          a : SymbolicElem() from elm.getElemA()
          b : SymbolicElem() from elm.getElemB()
          not( Reng( strt == el0 ) )
          not( Reng( strt == elm ) )
          not( Reng( strt == a ) )
          not( Reng( strt == b ) )
          ds: DroolsSession()
      then
         // System.out.println( "Distribute InvertRight Over Mult" );
         insert( new Reng( el0 , new SymbolicMult( new SymbolicInvertRight( b , el0.getFac().getFac() , ds ) , new SymbolicInvertRight( a , el0.getFac().getFac() , ds ) , elm.getFac().getFac() , ds ) ) );
end













rule "InvertLeft Over Negative"
      when
          el1 : SymbolicNegate( )
          el0 : SymbolicInvertLeft( elem == el1 )
          e0 : SymbolicElem() from el1.getElem()
          not( Reng( strt == el0 ) )
          not( Reng( strt == el1 ) )
          not( Reng( strt == e0 ) )
          ds: DroolsSession()
      then
         // System.out.println( "InvertLeft Over Negate" );
         insert( new Reng( el0 , new SymbolicNegate( new SymbolicInvertLeft( e0 , el0.getFac().getFac() , ds ) , el1.getFac().getFac() , ds ) ) );
end










rule "InvertRight Over Negative"
      when
          el1 : SymbolicNegate( )
          el0 : SymbolicInvertRight( elem == el1 )
          e0 : SymbolicElem() from el1.getElem()
          not( Reng( strt == el0 ) )
          not( Reng( strt == el1 ) )
          not( Reng( strt == e0 ) )
          ds: DroolsSession()
      then
         // System.out.println( "InvertRight Over Negate" );
         insert( new Reng( el0 , new SymbolicNegate( new SymbolicInvertRight( e0 , el0.getFac().getFac() , ds ) , el1.getFac().getFac() , ds ) ) );
end







rule "Partial Derivative Of Constant A --> Zero"
      when
          pd : PartialDerivativeOp( )
          red : SymbolicReduction( )
          mult : SymbolicMult( elemA == pd , elemB == red )
          not( Reng( strt == mult ) )
          not( Reng( strt == red ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( red.partialDerivativeReducesToZero( pd.getWithRespectTo() ) )
      then
         // System.out.println( "Partial Derivative Of Constant A --> Zero" );
         insert( new Reng( mult , new SymbolicZero( mult.getFac().getFac() , ds ) ) );
end






// This simplification has a parallel implementation in SymbolicZero.divideBy()
rule "DivideBy OF Zero --> Zero"
      when
          a : SymbolicZero( )
          b : SymbolicDivideBy( elem == a )
          not( Reng( strt == b ) )
          not( Reng( strt == a ) )
          ds : DroolsSession()
          eval( b.divNotZero() )
      then
          // System.out.println( "DivideBy OF Zero --> Zero" );
          insert( new Reng( b , a ) );
end







rule "Partial Derivative Of Constant B --> Zero"
      when
          pd : PartialDerivativeOp( )
          mult : SymbolicMult( elemA == pd )
          cn : SymbolicElem() from mult.getElemB()
          not( Reng( strt == mult ) )
          not( Reng( strt == cn ) )
          not( Reng( strt == pd ) )
          ds: DroolsSession()
          eval( cn.isPartialDerivativeZero() )
      then
         // System.out.println( "Partial Derivative Of Constant B --> Zero" );
         insert( new Reng( mult , new SymbolicZero( cn.getFac() , ds ) ) );
end








// This simplification has a parallel implementation in SymbolicIdentity.invertLeft()
rule "Invert Left Identity --> Identity"
      when
          ez : SymbolicIdentity( )
          n1 : SymbolicInvertLeft( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Invert Left Identity --> Identity" );
          insert( new Reng( n1 , ez ) );
end








// This simplification has a parallel implementation in SymbolicIdentity.invertRight()
rule "Invert Right Identity --> Identity"
      when
          ez : SymbolicIdentity( )
          n1 : SymbolicInvertRight( elem == ez )
          not( Reng( strt == n1 ) )
          not( Reng( strt == ez ) )
      then
          // System.out.println( "Invert Right Identity --> Ientity" );
          insert( new Reng( n1 , ez ) );
end






rule "Mult Negative Ident A"
      when
          ez : SymbolicIdentity( )
          nnez : SymbolicNegate( elem == ez )
          mult1 : SymbolicMult( elemA == nnez )
          nez : SymbolicElem() from mult1.getElemB()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nez ) )
          not( Reng( strt == nnez ) )
          not( Reng( strt == ez ) )
          not( eval( nez instanceof SymbolicNegate ) )
      then
          // System.out.println( "Mult Negative Ident A" );
          insert( new Reng( mult1 , nez.negate() ) );
end




rule "Mult Negative Ident B"
      when
          ez : SymbolicIdentity( )
          nnez : SymbolicNegate( elem == ez )
          mult1 : SymbolicMult( elemB == nnez )
          nez : SymbolicElem() from mult1.getElemA()
          not( Reng( strt == mult1 ) )
          not( Reng( strt == nez ) )
          not( Reng( strt == nnez ) )
          not( Reng( strt == ez ) )
          not( eval( nez instanceof SymbolicNegate ) )
          eval( !( nez.exposesDerivatives() ) )
      then
          // System.out.println( "Mult Negative Ident B" );
          insert( new Reng( mult1 , nez.negate() ) );
end



