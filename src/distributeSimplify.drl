

//$$strtCprt
//
// Simple Algebra 
// 
// Copyright (C) 2014 Thornton Green
// 
// This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
// published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
// This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
// of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with this program; if not, 
// see <http://www.gnu.org/licenses>.
// Additional permission under GNU GPL version 3 section 7
//
//
//$$endCprt

package simplealgebra.symbolic




rule "Reng Insert"

     when
          r0 : Reng( )
     then
          insert( r0.getEnd() );
end




rule "Apply Placeholder"
     when
          r0 : Reng( )
          p : SymbolicPlaceholder( elem == r0.getStrt() )
     then
          modify( p ){ setElem( r0.getEnd() ) };
end






rule "Apply Negate"
     when
          r0 : Reng( )
          p : SymbolicNegate( elem == r0.getStrt() )
     then
          insert( new Reng( p , new SymbolicNegate( r0.getEnd() , p.getFac() ) ) );
end





rule "Apply AddA"
     when
          r0 : Reng( )
          p : SymbolicAdd( elemA == r0.getStrt() )
     then
          insert( new Reng( p , new SymbolicAdd( r0.getEnd() , p.getElemB() , p.getFac() ) ) );
end





rule "Apply AddB"
     when
          r0 : Reng( )
          p : SymbolicAdd( elemB == r0.getStrt() )
     then
          insert( new Reng( p , new SymbolicAdd( p.getElemA() , r0.getEnd() , p.getFac() ) ) );
end





rule "Apply MultA"
     when
          r0 : Reng( )
          p : SymbolicMult( elemA == r0.getStrt() )
     then
          insert( new Reng( p , new SymbolicMult( r0.getEnd() , p.getElemB() , p.getFac() ) ) );
end





rule "Apply MultB"
     when
          r0 : Reng( )
          p : SymbolicMult( elemB == r0.getStrt() )
     then
          insert( new Reng( p , new SymbolicMult( p.getElemA() , r0.getEnd() , p.getFac() ) ) );
end





rule "Double Negate"
     when
          e0 : SymbolicElem( )
          n0 : SymbolicNegate( elem == e0 )
          n1 : SymbolicNegate( elem == n0 )
     then
          insert( new Reng( n1 , e0 ) );
end



rule "Negate Zero"
      when
          ez : SymbolicZero( )
          n1 : SymbolicNegate( elem == ez )
      then
          insert( new Reng( n1 , ez ) );
end



rule "Add Zero A"
      when
          ez : SymbolicZero( )
          nez : SymbolicElem( )
          add1 : SymbolicAdd( elemA == ez , elemB == nez )
      then
          insert( new Reng( add1 , nez ) );
end




rule "Add Zero B"
      when
          ez : SymbolicZero( )
          nez : SymbolicElem( )
          add1 : SymbolicAdd( elemA == nez , elemB == ez )
      then
          insert( new Reng( add1 , nez ) );
end





rule "Mult Ident A"
      when
          ez : SymbolicIdentity( )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == ez , elemB == nez )
      then
          insert( new Reng( mult1 , nez ) );
end




rule "Mult Ident B"
      when
          ez : SymbolicIdentity( )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == nez , elemB == ez )
      then
          insert( new Reng( mult1 , nez ) );
end




rule "Mult Zero A"
      when
          ez : SymbolicZero( )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == ez , elemB == nez )
      then
          insert( new Reng( mult1 , ez ) );
end




rule "Mult Zero B"
      when
          ez : SymbolicZero( )
          nez : SymbolicElem( )
          mult1 : SymbolicMult( elemA == nez , elemB == ez )
      then
          insert( new Reng( mult1 , ez ) );
end





rule "Mult Over Negate A"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          na : SymbolicNegate( elem == a )
          mult1 : SymbolicMult( elemA == na , elemB == b )
      then
          insert( new Reng( mult1 , new SymbolicNegate( new SymbolicMult( a , b , mult1.getFac() ) , na.getFac() ) ) );
end




rule "Mult Over Negate B"
      when
          a : SymbolicElem( )
          b : SymbolicElem( )
          nb : SymbolicNegate( elem == b )
          mult1 : SymbolicMult( elemA == a , elemB == nb )
      then
          insert( new Reng( mult1 , new SymbolicNegate( new SymbolicMult( a , b , mult1.getFac() ) , nb.getFac() ) ) );
end





// Needs to be revised !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
rule "El Plus Negative El"
      when
          elA : SymbolicElem( )
          elB : SymbolicElem( )
          add1 : SymbolicAdd( elemA == elA , elemB == elB )
          eval( elA.symbolicEquals( new SymbolicNegate( elB , elB.getFac() ) ) )
      then
          insert( new Reng( add1 , new SymbolicZero( elA.getFac() ) ) );
end





