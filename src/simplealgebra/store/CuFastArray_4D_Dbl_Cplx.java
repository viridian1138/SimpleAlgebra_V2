



//$$strtCprt
/**
* Simple Algebra 
* 
* Copyright (C) 2014 Thornton Green
* 
* This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation; either version 3 of the License, or (at your option) any later version.
* This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty 
* of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
* You should have received a copy of the GNU General Public License along with this program; if not, 
* see <http://www.gnu.org/licenses>.
* Additional permission under GNU GPL version 3 section 7
*
*/
//$$endCprt





package simplealgebra.store;


import java.io.RandomAccessFile;
import java.util.HashMap;




/**
 * Direct access entity resembling a dense 4-D array of complex numbers of doubles.  Basic layout of schema is a set of raw binaries, with the exception of endian reversal, generated by Nvidia Cuda code.
 * 
 * This documentation should be viewed using Firefox version 33.1.1 or above.
 * 
 * @author thorngreen
 */
public class CuFastArray_4D_Dbl_Cplx {
	
	
	/**
	 * Limit on number of files in the last used first out (LUFO) array of file indices.
	 */
	protected static int FILE_LIMIT = 10;
	
	
	/**
	 * Map from file indices to RandomAccessFile instances.
	 */
	protected HashMap<Integer,RandomAccessFile> files = new HashMap<Integer,RandomAccessFile>();
	
	/**
	 * Last used first out (LUFO) array of file indices in use.
	 */
	protected Integer[] fileLufo = new Integer[ FILE_LIMIT ];
	
	
	
	/**
	 * The size of each cell along the X-axis.
	 */
	long xmult;
	
	/**
	 * The size of each cell along the Y-axis.
	 */
	long ymult;
	
	/**
	 * The size of each cell along the Z-axis.
	 */
	long zmult;
	
	
	
	/**
	 * The size of the array along the T-axis.
	 */
	int tmax;
	
	/**
	 * The size of the array along the X-axis.
	 */
	int xmax;
	
	/**
	 * The size of the array along the Y-axis.
	 */
	int ymax;
	
	/**
	 * The size of the array along the Z-axis.
	 */
	int zmax;
	
	
	/**
	 * The path at which to get the array image on disk.
	 */
	String path;
	
	/**
	 * Whether the instance reads the imaginary part of the array as opposed to the real part of the array.
	 */
	boolean im;
	
	
	
	/**
	 * The size of a double-precision number in bytes.
	 */
	static final int SZ_DBL = 8;
	
	
	

	
	
	
	/**
	 * Constructs the array.
	 * 
	 * @param _param The input parameter.
	 * @param ipath The path at which to get the array image on disk.
	 * @param iim Whether the instance reads the imaginary part of the array as opposed to the real part of the array.
	 */
	public CuFastArray_4D_Dbl_Cplx( final DbFastArray4D_Param _param , String ipath , boolean iim ) throws Throwable
	{
		path = ipath;
		im = iim;
		
		tmax = _param.getTmax();
		xmax = _param.getXmax();
		ymax = _param.getYmax();
		zmax = _param.getZmax();
		
	
		xmult = 2;
		
		ymult = xmult * xmax;
		
		zmult = ymult * ymax;
	}
	
	
	
	
	
	
	/**
	 * Gets the object at the 4-D index.
	 * 
	 * @param t The "T" index of the array.
	 * @param x The "X" index of the array.
	 * @param y The "Y" index of the array.
	 * @param z The "Z" index of the array.
	 * @return The value at the 4-D index, or zero if no value exists.
	 */
	public double get( int t , int x , int y , int z ) throws Throwable
	{	
		if( ( x < 0 ) || ( x >= xmax ) )
		{
			return( 0.0 );
		}
		
		if( ( y < 0 ) || ( y >= ymax ) )
		{
			return( 0.0 );
		}
		
		if( ( z < 0 ) || ( z >= zmax ) )
		{
			return( 0.0 );
		}
		
		if( ( t < 0 ) || ( t >= tmax ) )
		{
			return( 0.0 );
		}
		
		RandomAccessFile file = files.get( t );
		
		
		if( file == null )
		{
			if( fileLufo[ FILE_LIMIT - 1 ] == null )
			{
				int index = 0;
				while( fileLufo[ index ] != null )
				{
					index++;
				}
				fileLufo[ index ] = Integer.valueOf( t );
				file = new RandomAccessFile( path + "/outD_" + ( t + 1 ) , "r" );
				files.put(t, file);
			}
			else
			{
				files.get( fileLufo[ 0 ] ).close();
				files.remove( fileLufo[ 0 ] );
				for( int cnt = 0 ; cnt < FILE_LIMIT - 1 ; cnt++ )
				{
					fileLufo[ cnt ] = fileLufo[ cnt + 1 ];
				}
				fileLufo[ FILE_LIMIT - 1 ] = Integer.valueOf( t );
				file = new RandomAccessFile( path + "/outD_" + ( t + 1 ) , "r" );
				files.put(t, file);
			}
		}
		
		
		long index = xmult * x + ymult * y + zmult * z + ( im ? 1 : 0 );
		
		
		file.seek( SZ_DBL * index );
		final double ret = file.readDouble();
		if( file.getFilePointer() != ( SZ_DBL * ( index + 1 ) ) )
		{
			throw( new RuntimeException( "Internal Error" ) );
		}
		
//		if( t == 0 )
//		{
//			System.out.println( ret );
//		}
		
		return( ret );
	}
	
	
	/**
	 * Closes the array.
	 */
	public void close() throws Throwable
	{
		for( final RandomAccessFile file : files.values() )
		{
			file.close();
		}
		files.clear();
		fileLufo = new Integer[ FILE_LIMIT ];
	}
	
	
	
	/**
	 * Flushes the contents of the previous array writes.
	 * 
	 * @throws Throwable
	 */
	public void flush( ) throws Throwable
	{
		for( final RandomAccessFile file : files.values() )
		{
			file.getFD().sync();
		}
	}
	
	

}

